// ==UserScript==
// @name         æ•™å­¦è¯„ä»·è‡ªåŠ¨åŒ–åŠ©æ‰‹
// @namespace    http://tampermonkey.net/
// @version      1.0.0
// @description  è‡ªåŠ¨å®Œæˆæ•™å­¦è¯„ä»·ç³»ç»Ÿè¯„åˆ†ï¼Œæ”¯æŒæ‰¹é‡å¤„ç†å’Œæ™ºèƒ½è¯„è¯­ç”Ÿæˆ
// @author       hepeng
// @match        *://10.252.6.31/jwglxt/xspjgl/xspj_cxXspjIndex.html*
// @match        *://*evaluation*
// @match        *://*eval*
// @match        *://*pingjia*
// @match        *://*course*
// @grant        none
// @run-at       document-start
// ==/UserScript==

// ==================== ç»•è¿‡è„šæœ¬æ³¨å…¥æ£€æµ‹ ====================
// åœ¨é¡µé¢è„šæœ¬åŠ è½½ä¹‹å‰æ‰§è¡Œï¼Œå°è¯•ç»•è¿‡ isTrusted æ£€æµ‹
(function() {
    'use strict';
    
    // æ–¹æ³•1ï¼šå°è¯•è¦†ç›– MouseEvent çš„ isTrusted å±æ€§
    try {
        const originalMouseEvent = window.MouseEvent;
        window.MouseEvent = function(type, eventInitDict) {
            const event = new originalMouseEvent(type, eventInitDict);
            // å°è¯•å®šä¹‰ isTrusted ä¸º trueï¼ˆå¯èƒ½ä¸ä¼šç”Ÿæ•ˆï¼Œå› ä¸ºæ˜¯åªè¯»å±æ€§ï¼‰
            try {
                Object.defineProperty(event, 'isTrusted', {
                    get: function() { return true; },
                    configurable: false
                });
            } catch (e) {}
            return event;
        };
        window.MouseEvent.prototype = originalMouseEvent.prototype;
        console.log('ğŸ”§ å·²å°è¯•è¦†ç›– MouseEvent');
    } catch (e) {
        console.log('âŒ è¦†ç›– MouseEvent å¤±è´¥', e);
    }
    
    // æ–¹æ³•2ï¼šHook bootbox.alert å‡½æ•°ï¼Œé˜»æ­¢è„šæœ¬æ³¨å…¥è­¦å‘Šå¼¹çª—
    const hookBootbox = function() {
        if (typeof window.bootbox !== 'undefined' && window.bootbox.alert) {
            // æ£€æŸ¥æ˜¯å¦å·²ç» Hook è¿‡
            if (window.bootbox.alert._isHooked) {
                return;
            }
            
            const originalAlert = window.bootbox.alert;
            window.bootbox.alert = function(options) {
                // æ£€æŸ¥æ˜¯å¦æ˜¯è„šæœ¬æ³¨å…¥è­¦å‘Š
                const message = typeof options === 'string' ? options : (options.message || '');
                console.log('ğŸ” bootbox.alert è¢«è°ƒç”¨ï¼Œæ¶ˆæ¯:', message.substring(0, 50));
                
                if (message.indexOf('è„šæœ¬æ³¨å…¥') >= 0 || 
                    message.indexOf('è‡ªåŠ¨è¯„ä»·') >= 0 ||
                    message.indexOf('è¯·å‹¿ä½¿ç”¨') >= 0) {
                    console.log('ğŸš« å·²æ‹¦æˆªè„šæœ¬æ³¨å…¥è­¦å‘Šå¼¹çª—');
                    // ä¸æ˜¾ç¤ºå¼¹çª—ï¼Œç›´æ¥è°ƒç”¨å›è°ƒ
                    if (options && options.callback && typeof options.callback === 'function') {
                        setTimeout(options.callback, 100);
                    }
                    // è¿”å›ä¸€ä¸ªå‡çš„ modal å¯¹è±¡
                    return { modal: function() { return this; } };
                }
                // å…¶ä»–å¼¹çª—æ­£å¸¸æ˜¾ç¤º
                return originalAlert.apply(this, arguments);
            };
            window.bootbox.alert._isHooked = true;
            window.bootbox.alert._original = originalAlert;
            console.log('ğŸ”§ å·² Hook bootbox.alert');
        }
    };
    
    // æ–¹æ³•2bï¼šHook bootbox.dialogï¼ˆæ›´åº•å±‚çš„æ–¹æ³•ï¼‰
    const hookBootboxDialog = function() {
        if (typeof window.bootbox !== 'undefined' && window.bootbox.dialog) {
            if (window.bootbox.dialog._isHooked) {
                return;
            }
            
            const originalDialog = window.bootbox.dialog;
            window.bootbox.dialog = function(options) {
                const message = options && options.message ? String(options.message) : '';
                console.log('ğŸ” bootbox.dialog è¢«è°ƒç”¨ï¼Œæ¶ˆæ¯:', message.substring(0, 50));
                
                if (message.indexOf('è„šæœ¬æ³¨å…¥') >= 0 || 
                    message.indexOf('è‡ªåŠ¨è¯„ä»·') >= 0 ||
                    message.indexOf('è¯·å‹¿ä½¿ç”¨') >= 0) {
                    console.log('ğŸš« å·²æ‹¦æˆªè„šæœ¬æ³¨å…¥è­¦å‘Šå¼¹çª— (dialog)');
                    
                    // è®¾ç½®æ ‡è®°ï¼Œè¡¨ç¤ºéœ€è¦ç»•è¿‡ä¿å­˜
                    window._needBypassSave = true;
                    console.log('ğŸ·ï¸ å·²è®¾ç½®ç»•è¿‡ä¿å­˜æ ‡è®°');
                    
                    return { modal: function() { return this; } };
                }
                return originalDialog.apply(this, arguments);
            };
            window.bootbox.dialog._isHooked = true;
            console.log('ğŸ”§ å·² Hook bootbox.dialog');
        }
    };
    
    // å­˜å‚¨æ•è·çš„ä¿å­˜è¯·æ±‚ä¿¡æ¯
    window._capturedSaveRequest = null;
    window._allAjaxRequests = [];
    
    // æ–¹æ³•3ï¼šHook jQuery.ajaxï¼Œç›‘æ§æ‰€æœ‰è¯·æ±‚å¹¶æ•è·ä¿å­˜URL
    const hookJQueryAjax = function() {
        if (typeof window.jQuery !== 'undefined' && !window.jQuery.ajax._isHooked) {
            const originalAjax = window.jQuery.ajax;
            window.jQuery.ajax = function(url, options) {
                // è§£æå‚æ•°
                let requestUrl = '';
                let requestData = '';
                let requestType = 'GET';
                
                if (typeof url === 'object') {
                    requestUrl = url.url || '';
                    requestData = url.data || '';
                    requestType = url.type || 'GET';
                } else {
                    requestUrl = url || '';
                    if (options) {
                        requestData = options.data || '';
                        requestType = options.type || 'GET';
                    }
                }
                
                // è®°å½•æ‰€æœ‰è¯·æ±‚
                const requestInfo = {
                    url: requestUrl,
                    type: requestType,
                    data: typeof requestData === 'string' ? requestData.substring(0, 200) : '(object)',
                    time: new Date().toLocaleTimeString()
                };
                window._allAjaxRequests.push(requestInfo);
                
                // ä¿ç•™æœ€è¿‘50æ¡è®°å½•
                if (window._allAjaxRequests.length > 50) {
                    window._allAjaxRequests.shift();
                }
                
                // æ£€æµ‹æ˜¯å¦æ˜¯ä¿å­˜è¯„ä»·çš„è¯·æ±‚ï¼ˆé€šè¿‡URLæˆ–æ•°æ®ç‰¹å¾åˆ¤æ–­ï¼‰
                const urlStr = String(requestUrl).toLowerCase();
                const dataStr = String(requestData).toLowerCase();
                
                if ((urlStr.indexOf('xspj') >= 0 && urlStr.indexOf('bc') >= 0) ||
                    (urlStr.indexOf('save') >= 0) ||
                    (urlStr.indexOf('xspj') >= 0 && requestType.toUpperCase() === 'POST')) {
                    console.log('ğŸ“¡ æ•è·åˆ°å¯èƒ½çš„ä¿å­˜è¯·æ±‚:', requestInfo);
                    window._capturedSaveRequest = {
                        url: requestUrl,
                        type: requestType,
                        fullUrl: url,
                        fullOptions: options,
                        capturedAt: new Date()
                    };
                }
                
                // å¦‚æœæ˜¯æ£€æµ‹è„šæœ¬æ³¨å…¥çš„è¯·æ±‚ï¼Œç›´æ¥è¿”å›æˆåŠŸ
                if (urlStr.indexOf('checkscript') >= 0) {
                    console.log('ğŸš« å·²æ‹¦æˆªè„šæœ¬æ£€æµ‹è¯·æ±‚');
                    return window.jQuery.Deferred().resolve({}).promise();
                }
                
                return originalAjax.apply(this, arguments);
            };
            window.jQuery.ajax._isHooked = true;
            window.jQuery.ajax._original = originalAjax;
            console.log('ğŸ”§ å·² Hook jQuery.ajaxï¼ˆå¸¦è¯·æ±‚ç›‘æ§ï¼‰');
        }
    };
    
    // æä¾›ä¸€ä¸ªå‡½æ•°æ¥æŸ¥çœ‹æ•è·çš„è¯·æ±‚
    window.showCapturedRequests = function() {
        console.log('ğŸ“‹ æœ€è¿‘çš„ AJAX è¯·æ±‚:');
        console.table(window._allAjaxRequests);
        if (window._capturedSaveRequest) {
            console.log('ğŸ’¾ æ•è·çš„ä¿å­˜è¯·æ±‚:', window._capturedSaveRequest);
        }
    };
    
    // æ‰§è¡Œæ‰€æœ‰ Hook
    const executeAllHooks = function() {
        hookBootbox();
        hookBootboxDialog();
        hookJQueryAjax();
    };
    
    // é¡µé¢åŠ è½½åæ‰§è¡Œ Hook - å·²ä¼˜åŒ–ï¼šå‡å°‘é‡å¤æ‰§è¡Œæ¬¡æ•°
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(executeAllHooks, 50);
            setTimeout(executeAllHooks, 300);
        });
    } else {
        setTimeout(executeAllHooks, 50);
        setTimeout(executeAllHooks, 300);
    }
    
    // å®šæœŸæ£€æŸ¥å¹¶é‡æ–° Hookï¼ˆé˜²æ­¢é¡µé¢è„šæœ¬è¦†ç›–ï¼‰- å·²ä¼˜åŒ–ï¼šå»¶é•¿é—´éš”
    setInterval(function() {
        executeAllHooks();
    }, 2000);
})();

(function() {
    'use strict';
    
    console.log("ğŸ¤– æ•™å­¦è¯„ä»·è‡ªåŠ¨åŒ–åŠ©æ‰‹å·²å¯åŠ¨ï¼");
    
    // ==================== å…¨å±€å˜é‡ ====================
    let isRunning = false;
    let isPaused = false;
    let currentProgress = 0;
    let totalCourses = 0;
    let processedCourses = 0;
    let evaluationResults = [];
    let injectionWarningObserver = null;
    let lastInjectionWarningHandledAt = 0;
    
    // ==================== é…ç½®é€‰é¡¹ ====================
    const config = {
        // è¯„åˆ†é…ç½®
        defaultScore: 100,
        lastItemScore: 90,
        
        // å»¶è¿Ÿé…ç½®ï¼ˆæ¯«ç§’ï¼‰- å·²ä¼˜åŒ–
        delayBetweenCourses: 1500,  // ä»3000msä¼˜åŒ–åˆ°1500ms
        delayBetweenActions: 400,   // ä»1000msä¼˜åŒ–åˆ°400ms
        typingDelay: 10,            // ä»50msä¼˜åŒ–åˆ°10ms
        
        // è¯„è¯­é…ç½®
        minCommentLength: 30,
        maxCommentLength: 50,
        
        // é‡è¯•é…ç½®
        maxRetries: 3,
        retryDelay: 1000,           // ä»2000msä¼˜åŒ–åˆ°1000ms
        
        // è°ƒè¯•é…ç½®
        enableDebug: true,
        showProgress: true,
        
        // é¡µé¢æ£€æµ‹é…ç½®
        pageLoadTimeout: 8000,      // ä»10000msä¼˜åŒ–åˆ°8000ms
        elementCheckInterval: 300,  // ä»500msä¼˜åŒ–åˆ°300ms
        
        // ä¿å­˜å‰ç­‰å¾…é…ç½®
        preSaveWaitTime: 0  // ä¿å­˜å‰ç­‰å¾…æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼Œè®¾ä¸º0è¡¨ç¤ºä¸ç­‰å¾…
    };
    
    // ==================== è¯„è¯­æ¨¡æ¿åº“ï¼ˆå¢å¼ºç‰ˆï¼‰====================
    // è¯„è¯­ç‰‡æ®µåº“ï¼Œç”¨äºéšæœºç»„åˆç”Ÿæˆå¤šæ ·åŒ–è¯„è¯­
    const commentParts = {
        // å¼€å¤´éƒ¨åˆ†
        start: [
            "è€å¸ˆæ•™å­¦è®¤çœŸè´Ÿè´£ï¼Œ",
            "è€å¸ˆä¸“ä¸šç´ å…»é«˜ï¼Œ",
            "è€å¸ˆå¤‡è¯¾å……åˆ†ï¼Œ",
            "è€å¸ˆè®²è§£ç»†è‡´ï¼Œ",
            "è€å¸ˆæ•™å­¦ç»éªŒä¸°å¯Œï¼Œ",
            "è€å¸ˆæ•™å­¦æ€åº¦ä¸¥è°¨ï¼Œ",
            "è€å¸ˆä¸“ä¸šèƒ½åŠ›å¼ºï¼Œ",
            "è€å¸ˆè¯¾å ‚ç»„ç»‡æœ‰åºï¼Œ",
            "è€å¸ˆæ•™å­¦é£æ ¼äº²åˆ‡ï¼Œ",
            "è€å¸ˆæ•™å­¦è´£ä»»å¿ƒå¼ºï¼Œ",
            "è¯¾ç¨‹å®‰æ’åˆç†ï¼Œ",
            "è¯¾ç¨‹è®¾è®¡ç§‘å­¦ï¼Œ",
            "è¯¾ç¨‹å†…å®¹å®ç”¨ï¼Œ",
            "æ•™å­¦æ–¹æ³•å¾—å½“ï¼Œ",
            "æ•™å­¦æ•ˆæœè‰¯å¥½ï¼Œ",
        ],
        // ä¸­é—´éƒ¨åˆ†
        middle: [
            "è¯¾ç¨‹å†…å®¹å……å®ï¼Œ",
            "æ•™å­¦å†…å®¹ä¸°å¯Œï¼Œ",
            "æˆè¯¾æ€è·¯æ¸…æ™°ï¼Œ",
            "é‡ç‚¹çªå‡ºï¼Œ",
            "ç†è®ºä¸å®è·µç»“åˆç´§å¯†ï¼Œ",
            "è¯¾å ‚æ°›å›´æ´»è·ƒï¼Œ",
            "æ•™å­¦æ–¹æ³•çµæ´»ï¼Œ",
            "æˆè¯¾æ¡ç†æ¸…æ™°ï¼Œ",
            "æ•™å­¦ç¯èŠ‚ç´§å‡‘ï¼Œ",
            "é‡ç‚¹éš¾ç‚¹çªå‡ºï¼Œ",
            "çŸ¥è¯†ç‚¹è®²è§£é€å½»ï¼Œ",
            "æ¡ˆä¾‹åˆ†æç”ŸåŠ¨ï¼Œ",
            "äº’åŠ¨ç¯èŠ‚ä¸°å¯Œï¼Œ",
            "æ•™å­¦ç›®æ ‡æ˜ç¡®ï¼Œ",
            "é€»è¾‘æ€§å¼ºï¼Œ",
        ],
        // ç»“å°¾éƒ¨åˆ†
        end: [
            "è®²è§£æ¸…æ™°æ˜“æ‡‚ã€‚",
            "æ•ˆæœæ˜¾è‘—ã€‚",
            "å­¦ç”Ÿå­¦ä¹ æ•ˆæœå¥½ã€‚",
            "å­¦ä¹ æ”¶è·å¾ˆå¤§ã€‚",
            "å—ç›ŠåŒªæµ…ã€‚",
            "æ•™å­¦æ•ˆæœä½³ã€‚",
            "å­¦ç”Ÿæ»¡æ„åº¦é«˜ã€‚",
            "è¾¾æˆæ•ˆæœå¥½ã€‚",
            "å­¦ä¹ å…´è¶£æµ“åšã€‚",
            "å­¦ä¹ è¿›æ­¥æ˜æ˜¾ã€‚",
            "æ•ˆç‡å¾ˆé«˜ã€‚",
            "ç§¯ææ€§è¢«å……åˆ†è°ƒåŠ¨ã€‚",
            "æ·±å…¥æµ…å‡ºï¼Œæ”¶è·é¢‡ä¸°ã€‚",
            "ä»¤äººæ»¡æ„ã€‚",
            "å€¼å¾—æ¨èã€‚",
        ]
    };
    
    // å®Œæ•´è¯„è¯­æ¨¡æ¿ï¼ˆå¤‡ç”¨ï¼‰
    const commentTemplates = [
        "è€å¸ˆæ•™å­¦è®¤çœŸè´Ÿè´£ï¼Œè¯¾ç¨‹å†…å®¹å……å®ï¼Œè®²è§£æ¸…æ™°æ˜“æ‡‚ã€‚",
        "æ•™å­¦æ–¹æ³•å¾—å½“ï¼Œç†è®ºä¸å®è·µç»“åˆç´§å¯†ï¼Œæ•ˆæœæ˜¾è‘—ã€‚",
        "è€å¸ˆå¤‡è¯¾å……åˆ†ï¼Œæˆè¯¾æ€è·¯æ¸…æ™°ï¼Œå­¦ç”Ÿå­¦ä¹ æ•ˆæœå¥½ã€‚",
        "è¯¾ç¨‹å®‰æ’åˆç†ï¼Œæ•™å­¦æ€åº¦è®¤çœŸï¼Œä¸“ä¸šçŸ¥è¯†æ‰å®ã€‚",
        "è€å¸ˆä¸“ä¸šç´ å…»é«˜ï¼Œæ•™å­¦å†…å®¹ä¸°å¯Œï¼Œè¯¾å ‚æ°›å›´æ´»è·ƒã€‚",
        "æ•™å­¦æ•ˆæœè‰¯å¥½ï¼Œèƒ½å¤Ÿæ¿€å‘å­¦ç”Ÿå­¦ä¹ å…´è¶£å’Œç§¯ææ€§ã€‚",
        "è€å¸ˆè®²è§£ç»†è‡´ï¼Œé‡ç‚¹çªå‡ºï¼Œå¸®åŠ©å­¦ç”Ÿç†è§£éš¾ç‚¹ã€‚",
        "è¯¾ç¨‹å†…å®¹å®ç”¨ï¼Œæ•™å­¦æ–¹æ³•çµæ´»ï¼Œå­¦ç”Ÿå­¦ä¹ æ”¶è·å¤§ã€‚",
        "è€å¸ˆæ•™å­¦ç»éªŒä¸°å¯Œï¼Œæˆè¯¾æ¡ç†æ¸…æ™°ï¼Œé€»è¾‘æ€§å¼ºã€‚",
        "è¯¾å ‚äº’åŠ¨è‰¯å¥½ï¼Œè€å¸ˆè€å¿ƒè§£ç­”é—®é¢˜ï¼Œæ•™å­¦æ•ˆæœä½³ã€‚",
        "è€å¸ˆæ•™å­¦æ€åº¦ä¸¥è°¨ï¼Œå¤‡è¯¾å……åˆ†ï¼Œå­¦ç”Ÿå­¦ä¹ æ»¡æ„åº¦é«˜ã€‚",
        "è¯¾ç¨‹è®¾è®¡åˆç†ï¼Œæ•™å­¦ç›®æ ‡æ˜ç¡®ï¼Œè¾¾æˆæ•ˆæœå¥½ã€‚",
        "è€å¸ˆä¸“ä¸šèƒ½åŠ›å¼ºï¼Œæ•™å­¦æ–¹æ³•åˆ›æ–°ï¼Œå­¦ç”Ÿå­¦ä¹ å…´è¶£æµ“ã€‚",
        "æ•™å­¦å†…å®¹å……å®ï¼Œé‡ç‚¹éš¾ç‚¹çªå‡ºï¼Œå­¦ç”Ÿå­¦ä¹ è¿›æ­¥æ˜æ˜¾ã€‚",
        "è€å¸ˆè¯¾å ‚ç»„ç»‡æœ‰åºï¼Œæ•™å­¦ç¯èŠ‚ç´§å‡‘ï¼Œæ•ˆç‡å¾ˆé«˜ã€‚",
        "è€å¸ˆæ•™å­¦é£æ ¼äº²åˆ‡ï¼Œå­¦ç”Ÿå­¦ä¹ ç§¯ææ€§è¢«å……åˆ†è°ƒåŠ¨ã€‚",
        "è¯¾ç¨‹å†…å®¹å‰æ²¿å®ç”¨ï¼Œè€å¸ˆè®²è§£æ·±å…¥æµ…å‡ºï¼Œå—ç›ŠåŒªæµ…ã€‚",
        "è€å¸ˆæ•™å­¦è´£ä»»å¿ƒå¼ºï¼Œå…³å¿ƒå­¦ç”Ÿï¼Œæ•™å­¦æ•ˆæœä»¤äººæ»¡æ„ã€‚"
    ];
    
    // éšæœºç”Ÿæˆç»„åˆè¯„è¯­
    function generateRandomComment() {
        const start = commentParts.start[Math.floor(Math.random() * commentParts.start.length)];
        const middle = commentParts.middle[Math.floor(Math.random() * commentParts.middle.length)];
        const end = commentParts.end[Math.floor(Math.random() * commentParts.end.length)];
        return start + middle + end;
    }
    
    // ==================== å·¥å…·å‡½æ•° ====================
    
    // å»¶è¿Ÿå‡½æ•°
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function interruptibleSleep(ms) {
        const interval = 200;
        let elapsed = 0;
        while (elapsed < ms && isRunning) {
            const chunk = Math.min(interval, ms - elapsed);
            await sleep(chunk);
            elapsed += chunk;
        }
    }
    
    // è°ƒè¯•æ—¥å¿—
    function debugLog(message, data = null) {
        if (config.enableDebug) {
            console.log(`[è°ƒè¯•] ${message}`, data || '');
        }
    }

    function getElementTextSafe(el) {
        if (!el) return '';
        try {
            return (el.textContent || '').trim();
        } catch (e) {
            return '';
        }
    }

    function isLikelyVisible(el) {
        if (!el) return false;
        try {
            const style = window.getComputedStyle ? window.getComputedStyle(el) : null;
            if (style) {
                if (style.display === 'none') return false;
                if (style.visibility === 'hidden') return false;
                if (parseFloat(style.opacity || '1') === 0) return false;
            }
            const rect = el.getBoundingClientRect ? el.getBoundingClientRect() : null;
            if (rect && rect.width === 0 && rect.height === 0) return false;
            return true;
        } catch (e) {
            return true;
        }
    }

    function isInjectionWarningText(text) {
        if (!text) return false;
        const t = String(text);
        const keywords = ['è„šæœ¬æ³¨å…¥', 'è‡ªåŠ¨è¯„ä»·', 'è¯·å‹¿ä½¿ç”¨', 'æ£€æµ‹åˆ°è‡ªåŠ¨è„šæœ¬'];
        for (let i = 0; i < keywords.length; i++) {
            if (t.indexOf(keywords[i]) >= 0) return true;
        }
        return false;
    }

    // æ£€æŸ¥æ˜¯å¦ä¸ºéœ€è¦è‡ªåŠ¨ç¡®è®¤çš„å¼¹çª—ï¼ˆåŒ…æ‹¬è­¦å‘Šå’ŒæˆåŠŸæç¤ºï¼‰
    function isAutoConfirmDialog(text) {
        if (!text) return false;
        const t = String(text);
        // è„šæœ¬æ³¨å…¥è­¦å‘Š
        if (isInjectionWarningText(t)) return true;
        // ä¿å­˜æˆåŠŸæç¤º
        if (t.indexOf('ä¿å­˜') >= 0 && t.indexOf('æˆåŠŸ') >= 0) return true;
        // è¯„ä»·æˆåŠŸæç¤º
        if (t.indexOf('è¯„ä»·') >= 0 && t.indexOf('æˆåŠŸ') >= 0) return true;
        // æäº¤æˆåŠŸæç¤º
        if (t.indexOf('æäº¤') >= 0 && t.indexOf('æˆåŠŸ') >= 0) return true;
        // æ“ä½œæˆåŠŸæç¤º
        if (t.indexOf('æ“ä½œ') >= 0 && t.indexOf('æˆåŠŸ') >= 0) return true;
        return false;
    }

    function tryClickConfirmInDialog(dialog) {
        if (!dialog) return false;

        const candidates = [];
        const selectors = ['button', 'input[type="button"]', 'input[type="submit"]', 'a'];
        for (let i = 0; i < selectors.length; i++) {
            let nodeList = [];
            try {
                nodeList = dialog.querySelectorAll(selectors[i]);
            } catch (e) {
                nodeList = [];
            }
            const len = typeof nodeList.length === 'number' ? nodeList.length : 0;
            for (let j = 0; j < len; j++) {
                candidates.push(nodeList[j]);
            }
        }

        for (let i = 0; i < candidates.length; i++) {
            const btn = candidates[i];
            if (!btn) continue;
            if (!isLikelyVisible(btn)) continue;
            const text = ((btn.textContent || btn.value || '') + '').replace(/\s+/g, '').trim();
            if (!text) continue;

            if (text === 'ç¡®å®š' || text === 'OK' || text === 'Ok' || text === 'ok' || text.indexOf('ç¡®å®š') >= 0) {
                try {
                    btn.click();
                    return true;
                } catch (e) {
                    try {
                        btn.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true, view: window }));
                        return true;
                    } catch (e2) {
                        return false;
                    }
                }
            }
        }

        return false;
    }

    function findAndConfirmInjectionWarningOnce() {
        const now = Date.now();
        if (now - lastInjectionWarningHandledAt < 300) return false;  // ç¼©çŸ­é—´éš”åˆ°300msï¼Œæ›´å¿«å“åº”

        const dialogSelectors = [
            '#alertModal',
            '.bootbox.modal',
            '.bootbox',
            '.modal',
            '[role="dialog"]',
            '.layui-layer',  // layui å¼¹çª—
            '.layer',
            '.alert',
            '.confirm'
        ];

        const dialogs = [];
        for (let i = 0; i < dialogSelectors.length; i++) {
            let nodeList = [];
            try {
                nodeList = document.querySelectorAll(dialogSelectors[i]);
            } catch (e) {
                nodeList = [];
            }
            const len = typeof nodeList.length === 'number' ? nodeList.length : 0;
            for (let j = 0; j < len; j++) {
                dialogs.push(nodeList[j]);
            }
        }

        for (let i = 0; i < dialogs.length; i++) {
            const dialog = dialogs[i];
            if (!dialog) continue;
            if (!isLikelyVisible(dialog)) continue;
            const text = getElementTextSafe(dialog);
            
            // å¤„ç†æ‰€æœ‰éœ€è¦è‡ªåŠ¨ç¡®è®¤çš„å¼¹çª—
            if (!isAutoConfirmDialog(text)) continue;

            const clicked = tryClickConfirmInDialog(dialog);
            if (clicked) {
                lastInjectionWarningHandledAt = Date.now();
                const dialogType = isInjectionWarningText(text) ? 'è„šæœ¬æ³¨å…¥è­¦å‘Š' : 'æ“ä½œæç¤º';
                debugLog(`å·²è‡ªåŠ¨å…³é—­å¼¹çª—: ${dialogType}`, text.substring(0, 50));
                return true;
            }
        }

        return false;
    }

    function startInjectionWarningAutoCloser() {
        if (injectionWarningObserver) return;

        try {
            findAndConfirmInjectionWarningOnce();
        } catch (e) {}

        try {
            injectionWarningObserver = new MutationObserver(() => {
                try {
                    findAndConfirmInjectionWarningOnce();
                } catch (e) {}
            });
            injectionWarningObserver.observe(document.documentElement || document.body, {
                childList: true,
                subtree: true
            });
        } catch (e) {
            injectionWarningObserver = null;
        }
    }

    function stopInjectionWarningAutoCloser() {
        try {
            if (injectionWarningObserver) injectionWarningObserver.disconnect();
        } catch (e) {}
        injectionWarningObserver = null;
    }
    
    // éšæœºå»¶è¿Ÿ
    function randomDelay(min, max = null) {
        if (max === null) {
            max = min;
            min = 0;
        }
        const delay = Math.random() * (max - min) + min;
        return sleep(delay);
    }
    
    // å®‰å…¨çš„ some å‡½æ•°
    function safeSome(list, predicate) {
        if (!list) return false;
        const length = typeof list.length === 'number' ? list.length : 0;
        for (let i = 0; i < length; i++) {
            let ok = false;
            try {
                ok = predicate(list[i], i);
            } catch (error) {
                ok = false;
            }
            if (ok) return true;
        }
        return false;
    }
    
    // å®‰å…¨çš„ filter å‡½æ•°
    function safeFilter(list, predicate) {
        const results = [];
        if (!list) return results;
        const length = typeof list.length === 'number' ? list.length : 0;
        for (let i = 0; i < length; i++) {
            const item = list[i];
            let ok = false;
            try {
                ok = predicate(item, i);
            } catch (error) {
                ok = false;
            }
            if (ok) results.push(item);
        }
        return results;
    }
    
    // æ£€æŸ¥æš‚åœçŠ¶æ€
    async function checkPause() {
        while (isPaused && isRunning) {
            await sleep(1000);
        }
    }
    
    /**
     * å¸¦æš‚åœæ„ŸçŸ¥çš„ç­‰å¾…å‡½æ•°
     * @param {number} totalMs - æ€»ç­‰å¾…æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
     * @param {function} onTick - æ¯ç§’å›è°ƒï¼Œå‚æ•°ä¸º {remaining: number, paused: boolean}
     * @returns {Promise<boolean>} - æ­£å¸¸å®Œæˆè¿”å› trueï¼Œè¢«åœæ­¢è¿”å› false
     */
    async function pauseAwareWait(totalMs, onTick = null) {
        // å¤„ç†é›¶æˆ–è´Ÿæ•°ç­‰å¾…æ—¶é—´
        if (totalMs <= 0) {
            return true;
        }
        
        const tickInterval = 100;  // æ£€æŸ¥é—´éš” 100ms
        let elapsedMs = 0;
        let lastTickSecond = -1;
        
        while (elapsedMs < totalMs) {
            // æ£€æŸ¥æ˜¯å¦åœæ­¢
            if (!isRunning) {
                return false;
            }
            
            // æ£€æŸ¥æ˜¯å¦æš‚åœ
            if (isPaused) {
                // æš‚åœæ—¶è°ƒç”¨å›è°ƒæ˜¾ç¤ºæš‚åœçŠ¶æ€
                if (onTick) {
                    const remainingSeconds = Math.ceil((totalMs - elapsedMs) / 1000);
                    try {
                        onTick({ remaining: remainingSeconds, paused: true });
                    } catch (e) {
                        // å¿½ç•¥å›è°ƒå¼‚å¸¸
                    }
                }
                await sleep(tickInterval);
                continue;  // æš‚åœæ—¶ä¸å¢åŠ å·²ç”¨æ—¶é—´
            }
            
            // æ¯ç§’è°ƒç”¨ä¸€æ¬¡å›è°ƒ
            const currentSecond = Math.floor(elapsedMs / 1000);
            if (onTick && currentSecond !== lastTickSecond) {
                const remainingSeconds = Math.ceil((totalMs - elapsedMs) / 1000);
                try {
                    onTick({ remaining: remainingSeconds, paused: false });
                } catch (e) {
                    // å¿½ç•¥å›è°ƒå¼‚å¸¸
                }
                lastTickSecond = currentSecond;
            }
            
            await sleep(tickInterval);
            elapsedMs += tickInterval;
        }
        
        return true;
    }
    
    // ==================== è¯¾ç¨‹ç®¡ç†æ¨¡å— ====================
    
    class CourseManager {
        constructor() {
            this.selectors = {
                courseRows: [
                    '#tempGrid tr.ui-widget-content.jqgrow',  // ç²¾ç¡®çš„jqGridæ•°æ®è¡Œ
                    '.ui-jqgrid-btable tr.ui-widget-content.jqgrow',   // jqGridä¸»ä½“æ•°æ®è¡Œ
                    'table.table-bordered tr',   // å¸¦è¾¹æ¡†çš„è¡¨æ ¼
                    '.table-xspj tr',         // è¯„ä»·è¡¨æ ¼
                    'table tbody tr',
                    '.course-table tr',
                    '.evaluation-list tr',
                    '[class*="course"] tr',
                    '[class*="eval"] tr',
                    'table tr'
                ],
                courseItems: [
                    '.course-item',
                    '.evaluation-item',
                    '[class*="course-row"]',
                    '[class*="eval-item"]'
                ],
                statusCell: [
                    'td:nth-child(8)',      // ç¬¬8åˆ—çŠ¶æ€ï¼ˆæ ¹æ®å®é™…HTMLç»“æ„ï¼‰
                    'td:nth-child(1)',      // ç¬¬ä¸€åˆ—çŠ¶æ€ï¼ˆå¤‡ç”¨ï¼‰
                    '.status',
                    '[class*="status"]',
                    '.state',
                    'td[data-status]'
                ],
                teacherCell: [
                    'td:nth-child(9)',      // ç¬¬9åˆ—æ•™å¸ˆï¼ˆæ ¹æ®å®é™…HTMLç»“æ„ï¼‰
                    'td:nth-child(2)',      // ç¬¬äºŒåˆ—æ•™å¸ˆï¼ˆå¤‡ç”¨ï¼‰
                    '.teacher',
                    '[class*="teacher"]'
                ],
                courseCell: [
                    'td:nth-child(10)',     // ç¬¬10åˆ—è¯¾ç¨‹ï¼ˆæ ¹æ®å®é™…HTMLç»“æ„ï¼‰
                    'td:nth-child(3)',      // ç¬¬ä¸‰åˆ—è¯¾ç¨‹ï¼ˆå¤‡ç”¨ï¼‰
                    '.course-name',
                    '[class*="course"]'
                ]
            };
        }

        // ç­‰å¾…jqGridæ•°æ®åŠ è½½å®Œæˆ - å·²ä¼˜åŒ–
        async waitForJqGridData() {
            debugLog("ç­‰å¾…jqGridæ•°æ®åŠ è½½...");
            const maxWaitTime = 12000; // ä»20ç§’ä¼˜åŒ–åˆ°12ç§’
            const checkInterval = 300; // ä»500msä¼˜åŒ–åˆ°300ms
            let waitTime = 0;
             
            while (waitTime < maxWaitTime) {
                // æ£€æŸ¥jqGridæ˜¯å¦å­˜åœ¨
                const jqGridTables = document.querySelectorAll('.ui-jqgrid-btable, #tempGrid');
                if (jqGridTables.length > 0) {
                    // æ£€æŸ¥æ˜¯å¦æœ‰æ•°æ®è¡Œ
                    let dataRowsFound = false;
                    for (const table of jqGridTables) {
                        const dataRows = table.querySelectorAll('tr.ui-widget-content.jqgrow');
                        if (dataRows.length > 0) {
                            debugLog(`åœ¨è¡¨æ ¼ ${table.id || table.className} ä¸­æ‰¾åˆ° ${dataRows.length} è¡Œæ•°æ®`);
                            
                            // æ£€æŸ¥æ•°æ®è¡Œæ˜¯å¦æœ‰å®é™…å†…å®¹
                            const hasValidContent = safeSome(dataRows, (row) => {
                                if (!row || !row.querySelectorAll) {
                                    debugLog("å‘ç°æ— æ•ˆçš„rowå…ƒç´ ");
                                    return false;
                                }
                                const cells = row.querySelectorAll('td');
                                const validCells = safeSome(cells, (cell) => {
                                    if (!cell) return false;
                                    const cellText = (cell.textContent || '').trim();
                                    return cellText.length > 0 && !(/^[a-f0-9]{20,}$/i.test(cellText));
                                });
                                
                                if (cells && cells.length > 0 && cells[0]) {
                                    const firstCellText = (cells[0].textContent || '').trim();
                                    debugLog(`è¡Œå†…å®¹æ£€æŸ¥: å•å…ƒæ ¼æ•°=${cells.length}, é¦–ä¸ªå•å…ƒæ ¼å†…å®¹=${firstCellText.substring(0, 20)}...`);
                                }
                                
                                return validCells;
                            });
                            
                            // æ”¾å®½éªŒè¯æ¡ä»¶ï¼šåªè¦æœ‰è¶³å¤Ÿçš„æ•°æ®è¡Œå°±è®¤ä¸ºæ˜¯æœ‰æ•ˆçš„
                            if (hasValidContent || dataRows.length >= 5) { // è°ƒæ•´ä¸º5è¡Œï¼Œæ›´å®½æ¾
                                dataRowsFound = true;
                                debugLog(`jqGridæ•°æ®å·²åŠ è½½ï¼Œæ‰¾åˆ° ${dataRows.length} è¡Œæ•°æ®ï¼Œæœ‰æ•ˆå†…å®¹: ${hasValidContent}`);
                                break;
                            }
                        }
                    }
                    
                    if (dataRowsFound) {
                        return true;
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦æœ‰åŠ è½½æŒ‡ç¤ºå™¨
                const loadingIndicators = document.querySelectorAll('.loading, .spinner, [class*="loading"]');
                const isLoading = safeSome(loadingIndicators, (indicator) => {
                    if (!indicator || !indicator.style) return false;
                    return indicator.offsetParent !== null && indicator.style.display !== 'none';
                });
                
                if (!isLoading && waitTime > 2000) { // å¦‚æœæ²¡æœ‰åŠ è½½æŒ‡ç¤ºå™¨ä¸”å·²ç­‰å¾…2ç§’
                    debugLog("æœªæ£€æµ‹åˆ°åŠ è½½æŒ‡ç¤ºå™¨ï¼Œå‡è®¾æ•°æ®å·²åŠ è½½");
                    return true;
                }
                
                await sleep(checkInterval);
                waitTime += checkInterval;
            }
            
            debugLog("jqGridæ•°æ®åŠ è½½è¶…æ—¶");
            return false;
        }

        async ensurePageSize(pageSize) {
            try {
                const target = String(pageSize);
                
                // ç­‰å¾…ä¸‹æ‹‰æ¡†å‡ºç°ï¼ˆæœ€å¤šç­‰å¾…1ç§’ï¼‰- å·²ä¼˜åŒ–
                let select = null;
                for (let i = 0; i < 10; i++) {
                    select = document.querySelector('select.ui-pg-selbox[name="currentPage"]');
                    if (select) break;
                    await sleep(100);
                }
                
                if (!select) return false;

                const current = String(select.value || '');
                if (current === target) return true;

                // æ£€æŸ¥æ˜¯å¦æœ‰ç›®æ ‡é€‰é¡¹
                let hasOption = false;
                const options = select.options || [];
                for (let i = 0; i < options.length; i++) {
                    if (String(options[i]?.value) === target) {
                        hasOption = true;
                        break;
                    }
                }
                if (!hasOption) return false;

                // è®¾ç½®æ–°å€¼å¹¶è§¦å‘äº‹ä»¶
                select.value = target;
                select.dispatchEvent(new Event('change', { bubbles: true }));
                if (typeof jQuery !== 'undefined') {
                    try { jQuery(select).trigger('change'); } catch (e) {}
                }

                debugLog(`æ¯é¡µæ¡æ•°: ${current} â†’ ${target}`);
                
                // ç­‰å¾…æ•°æ®é‡æ–°åŠ è½½ - å·²ä¼˜åŒ–
                await sleep(200);
                await this.waitForJqGridData();
                return true;
            } catch (e) {
                return false;
            }
        }
        
        // è·å–æ‰€æœ‰è¯¾ç¨‹
        async getAllCourses() {
            const courses = [];

            await this.ensurePageSize(50);
            
            // é¦–å…ˆç­‰å¾…jqGridæ•°æ®åŠ è½½
            await this.waitForJqGridData();
            
            // å°è¯•è¡¨æ ¼è¡Œæ–¹å¼
            let courseElements = await this.findCourseElements('courseRows');
            
            // å¦‚æœè¡¨æ ¼æ–¹å¼å¤±è´¥ï¼Œå°è¯•è¯¾ç¨‹é¡¹æ–¹å¼
            if (courseElements.length === 0) {
                courseElements = await this.findCourseElements('courseItems');
            }
            
            // å¦‚æœè¿˜æ˜¯æ²¡æ‰¾åˆ°ï¼Œå°è¯•æ›´å¤šé€‰æ‹©å™¨
            if (courseElements.length === 0) {
                courseElements = await this.findCourseElementsAlternative();
            }
            
            // è§£æè¯¾ç¨‹ä¿¡æ¯
            for (let i = 0; i < courseElements.length; i++) {
                const element = courseElements[i];
                const courseInfo = await this.parseCourseInfo(element);
                if (courseInfo) {
                    courses.push(courseInfo);
                }
            }
            
            debugLog(`æ‰¾åˆ° ${courses.length} é—¨è¯¾ç¨‹`);
            return courses;
        }
        
        // æŸ¥æ‰¾è¯¾ç¨‹å…ƒç´ 
        async findCourseElements(selectorType) {
            const selectors = this.selectors[selectorType];
            
            for (const selector of selectors) {
                const elements = document.querySelectorAll(selector);
                const validElements = [];
                for (let i = 0; i < elements.length; i++) {
                    const el = elements[i];
                    if (this.isValidCourseElement(el)) {
                        validElements.push(el);
                    }
                }
                
                if (validElements.length > 0) {
                    debugLog(`ä½¿ç”¨é€‰æ‹©å™¨ "${selector}" æ‰¾åˆ° ${validElements.length} ä¸ªè¯¾ç¨‹å…ƒç´ `);
                    return validElements;
                }
            }
            
            return [];
        }
        
        // å¤‡ç”¨å…ƒç´ æŸ¥æ‰¾æ–¹æ³•
        async findCourseElementsAlternative() {
            debugLog("ä½¿ç”¨å¤‡ç”¨é€‰æ‹©å™¨æŸ¥æ‰¾è¯¾ç¨‹å…ƒç´ ");
            
            const alternativeSelectors = [
                'tr',
                'tbody tr',
                'table tr',
                '.ui-jqgrid tr',
                '[role="row"]',
                '.row',
                '[class*="row"]'
            ];
            
            for (const selector of alternativeSelectors) {
                try {
                    const elements = document.querySelectorAll(selector);
                    debugLog(`å¤‡ç”¨é€‰æ‹©å™¨ "${selector}" æ‰¾åˆ° ${elements.length} ä¸ªå…ƒç´ `);
                    
                    const validElements = [];
                    for (let i = 0; i < elements.length; i++) {
                        const el = elements[i];
                        if (this.isValidCourseElement(el)) {
                            validElements.push(el);
                        }
                    }
                    
                    if (validElements.length > 0) {
                        debugLog(`å¤‡ç”¨é€‰æ‹©å™¨ "${selector}" æ‰¾åˆ° ${validElements.length} ä¸ªæœ‰æ•ˆè¯¾ç¨‹å…ƒç´ `);
                        return validElements;
                    }
                } catch (error) {
                    debugLog(`å¤‡ç”¨é€‰æ‹©å™¨ "${selector}" æ‰§è¡Œå¤±è´¥`, error);
                }
            }
            
            return [];
        }
        
        // éªŒè¯æ˜¯å¦ä¸ºæœ‰æ•ˆè¯¾ç¨‹å…ƒç´ 
        isValidCourseElement(element) {
            // æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨
            if (!element || !element.textContent) {
                return false;
            }
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºjqGridçš„ç‰¹æ®Šè¡Œï¼ˆæ’é™¤è¡¨å¤´å’Œç©ºè¡Œï¼‰
            const className = element.className || '';
            // åªæ’é™¤çœŸæ­£çš„æ— æ•ˆè¡Œï¼Œä¿ç•™jqGridæ•°æ®è¡Œ
            if (className.includes('jqgfirstrow') ||
                className.includes('ui-jqgrid-labels') ||
                className.includes('ui-pg-table')) {
                return false;
            }
            
            // jqGridæ•°æ®è¡ŒåŒ…å« ui-widget-content jqgrow ui-row-ltrï¼Œä½†å®ƒä»¬æ˜¯æœ‰æ•ˆçš„è¯¾ç¨‹æ•°æ®
            const text = element.textContent.toLowerCase();
            const cells = element.querySelectorAll('td');
            const isJqGridRow = element.className.includes('ui-widget-content jqgrow');
           
            // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„å•å…ƒæ ¼ï¼ˆè‡³å°‘8åˆ—ï¼Œæ ¹æ®å®é™…HTMLç»“æ„ï¼‰
            const hasEnoughCells = cells.length >= 8;
           
            // æ£€æŸ¥å•å…ƒæ ¼æ˜¯å¦æœ‰å®é™…å†…å®¹
            const hasValidContent = safeSome(cells, (cell) => {
                if (!cell) return false;
                return (cell.textContent || '').trim().length > 1;
            });
           
            // å¯¹äºjqGridè¡Œï¼Œä½¿ç”¨æ›´ç²¾ç¡®çš„éªŒè¯é€»è¾‘
            let hasCourseInfo = false;
            if (isJqGridRow) {
                // jqGridè¡Œçš„éªŒè¯é€»è¾‘ï¼š
                // 1. å¿…é¡»æœ‰è¶³å¤Ÿçš„å•å…ƒæ ¼ï¼ˆè‡³å°‘8åˆ—ï¼‰
                // 2. å¿…é¡»æœ‰å†…å®¹ï¼ˆåŠ å¯†æ•°æ®ä¹Ÿç®—ï¼‰
                // 3. æ£€æŸ¥æ˜¯å¦åŒ…å«è¯¾ç¨‹ç›¸å…³ç‰¹å¾
                hasCourseInfo = hasEnoughCells && hasValidContent;
                
                // æ£€æŸ¥æ˜¯å¦åŒ…å«è¯¾ç¨‹ç›¸å…³ä¿¡æ¯ï¼ˆæ•™å¸ˆåã€è¯¾ç¨‹åç­‰ï¼‰
                if (hasCourseInfo) {
                    // æ£€æŸ¥å…³é”®åˆ—çš„å†…å®¹
                    const statusCell = cells[7]; // ç¬¬8åˆ—çŠ¶æ€
                    const teacherCell = cells[8]; // ç¬¬9åˆ—æ•™å¸ˆ
                    const courseCell = cells[9]; // ç¬¬10åˆ—è¯¾ç¨‹
                    const classCell = cells[10]; // ç¬¬11åˆ—æ•™å­¦ç­
                    
                    const statusText = statusCell ? (statusCell.textContent || '').trim() : '';
                    const teacherText = teacherCell ? (teacherCell.textContent || '').trim() : '';
                    const courseText = courseCell ? (courseCell.textContent || '').trim() : '';
                    const classText = classCell ? (classCell.textContent || '').trim() : '';
                    
                    debugLog(`è¯¾ç¨‹è¡Œè¯¦ç»†éªŒè¯: çŠ¶æ€="${statusText}", æ•™å¸ˆ="${teacherText}", è¯¾ç¨‹="${courseText.substring(0, 20)}...", æ•™å­¦ç­="${classText.substring(0, 20)}..."`);
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰ä¸­æ–‡å†…å®¹ï¼ˆè¯¾ç¨‹åã€æ•™å¸ˆåç­‰ï¼‰
                    const hasChineseContent = /[\u4e00-\u9fa5]/.test(teacherText + courseText + classText);
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰åŠ å¯†IDï¼ˆè¯´æ˜è¿™æ˜¯æœ‰æ•ˆçš„æ•°æ®è¡Œï¼‰
                    let hasEncryptedId = false;
                    for (let i = 0; i < cells.length; i++) {
                        const cell = cells[i];
                        if (!cell) continue;
                        const cellText = (cell.textContent || '').trim();
                        if (i < 5 && cellText && /^[a-f0-9]{20,}$/i.test(cellText)) {
                            hasEncryptedId = true;
                            break;
                        }
                    }
                    
                    // æ£€æŸ¥çŠ¶æ€æ˜¯å¦åŒ…å«è¯„ä»·ç›¸å…³ä¿¡æ¯
                    const hasEvaluationStatus = statusText.includes('æœªè¯„') ||
                                                 statusText.includes('å·²è¯„') ||
                                                 statusText.includes('å¾…è¯„');
                    
                    // æ£€æŸ¥æ˜¯å¦åœ¨jqGridè¡¨æ ¼ä¸­
                    const parentTable = element.closest('#tempGrid, .ui-jqgrid-btable');
                    const isInValidTable = parentTable !== null;
                    
                    debugLog(`è¯¾ç¨‹è¡ŒéªŒè¯ç»“æœ: ä¸­æ–‡å†…å®¹=${hasChineseContent}, åŠ å¯†ID=${hasEncryptedId}, è¯„ä»·çŠ¶æ€=${hasEvaluationStatus}, æœ‰æ•ˆè¡¨æ ¼=${isInValidTable}, å•å…ƒæ ¼æ•°=${cells.length}`);
                    
                    // åªè¦æ»¡è¶³ä»¥ä¸‹ä»»ä¸€æ¡ä»¶å°±è®¤ä¸ºæ˜¯æœ‰æ•ˆè¯¾ç¨‹è¡Œï¼š
                    // 1. æœ‰è¯„ä»·çŠ¶æ€ï¼ˆæœ€å¯é çš„æ ‡è¯†ï¼‰
                    // 2. æœ‰ä¸­æ–‡å†…å®¹ä¸”åœ¨æœ‰æ•ˆè¡¨æ ¼ä¸­
                    // 3. æœ‰åŠ å¯†IDä¸”åœ¨æœ‰æ•ˆè¡¨æ ¼ä¸­
                    // 4. æœ‰è¶³å¤Ÿå¤šçš„å•å…ƒæ ¼ï¼ˆè¯´æ˜æ˜¯æ•°æ®è¡Œï¼‰
                    hasCourseInfo = hasEvaluationStatus ||
                                   (hasChineseContent && isInValidTable) ||
                                   (hasEncryptedId && isInValidTable) ||
                                   (cells.length >= 12); // è‡³å°‘12åˆ—è¯´æ˜æ˜¯å®Œæ•´çš„æ•°æ®è¡Œ
                }
            } else {
                // æ™®é€šè¡Œéœ€è¦åŒ…å«è¯¾ç¨‹ç›¸å…³ä¿¡æ¯
                hasCourseInfo = text.includes('è¯¾ç¨‹') ||
                              text.includes('æ•™å¸ˆ') ||
                              text.includes('æ•™å­¦ç­') ||
                              text.includes('æœªè¯„') ||
                              text.includes('å·²è¯„') ||
                              text.includes('è¯„ä»·') ||
                              text.includes('å­¦åˆ†') ||
                              text.includes('å­¦æ—¶') ||
                              text.includes('web') ||
                              text.includes('ç¨‹åºè®¾è®¡') ||
                              text.includes('è®¡ç®—æœº') ||
                              // æ£€æŸ¥æ˜¯å¦åŒ…å«ä¸­æ–‡è¯¾ç¨‹åç‰¹å¾
                              /[\u4e00-\u9fa5]{2,}/.test(text);
            }
           
            // æ£€æŸ¥æ˜¯å¦ä¸ºè¡¨å¤´è¡Œ
            const isHeader = (text.includes('çŠ¶æ€') &&
                            text.includes('æ•™å¸ˆ') &&
                            text.includes('è¯¾ç¨‹')) ||
                           (text.includes('çŠ¶æ€') &&
                            text.includes('æ•™å¸ˆ') &&
                            text.includes('è¯¾ç¨‹åç§°'));
           
            const hasChildren = element.children && element.children.length > 0;
            const notEmpty = text.trim().length > 3;
           
            return hasCourseInfo && !isHeader && hasEnoughCells && hasChildren && notEmpty && hasValidContent;
        }
        
        // jqGrid: é€šè¿‡ aria-describedby= tempGrid_xxx è¯»å–å•å…ƒæ ¼
        getJqGridCellText(element, fieldName) {
            const td = element.querySelector(`td[aria-describedby="tempGrid_${fieldName}"]`);
            if (!td) return '';
            return (td.getAttribute('title') || td.textContent || '').trim();
        }
        
        // è§£æè¯¾ç¨‹ä¿¡æ¯
        async parseCourseInfo(element) {
            try {
                const status = this.getCourseStatus(element);
                const courseName = this.getCourseName(element);
                const teacherName = this.getTeacherName(element);
                
                // è·å–è¯¦ç»†çš„è¯¾ç¨‹ä¿¡æ¯
                const courseDetails = this.getCourseDetails(element);
                
                return {
                    element: element,
                    status: status,
                    courseName: courseName,
                    teacherName: teacherName,
                    courseId: courseDetails.id,
                    courseCode: courseDetails.courseId,
                    teacherId: courseDetails.teacherId,
                    className: courseDetails.className,
                    courseType: courseDetails.courseType,
                    operation: courseDetails.operation,
                    isEvaluated: status.includes('å·²è¯„') || status.includes('å®Œæˆ'),
                    needsEvaluation: status.includes('æœªè¯„') || status.includes('å¾…è¯„')
                };
            } catch (error) {
                debugLog('è§£æè¯¾ç¨‹ä¿¡æ¯å¤±è´¥', error);
                return null;
            }
        }
        
        // è·å–è¯¾ç¨‹çŠ¶æ€
        getCourseStatus(element) {
            // æ£€æŸ¥æ˜¯å¦ä¸ºjqGridæ•°æ®è¡Œ
            const isJqGridRow = element.className.includes('ui-widget-content jqgrow');
            
            if (isJqGridRow) {
                // jqGrid: ä¼˜å…ˆæŒ‰å­—æ®µåè¯»å–ï¼ˆæ¯”å›ºå®šåˆ—å·æ›´ç¨³ï¼‰
                const raw = this.getJqGridCellText(element, 'tjztmc');
                if (raw) return raw;
            } else {
                // æ™®é€šè¡¨æ ¼å¤„ç†
                const statusSelectors = this.selectors.statusCell;
                
                for (const selector of statusSelectors) {
                    const statusElement = element.querySelector(selector);
                    if (statusElement) {
                        return statusElement.textContent.trim();
                    }
                }
                
                // ä»æ–‡æœ¬ä¸­æå–
                const text = element.textContent;
                const statusMatch = text.match(/(æœªè¯„|å·²è¯„|å¾…è¯„|å®Œæˆ|è¿›è¡Œä¸­|ä¿å­˜)/);
                return statusMatch ? statusMatch[1] : 'æœªçŸ¥';
            }
            
            return 'æœªè¯„'; // é»˜è®¤è¿”å›æœªè¯„çŠ¶æ€
        }
        
        // è·å–è¯¾ç¨‹åç§°
        getCourseName(element) {
            // æ£€æŸ¥æ˜¯å¦ä¸ºjqGridæ•°æ®è¡Œ
            const isJqGridRow = element.className.includes('ui-widget-content jqgrow');
            
            if (isJqGridRow) {
                const text = this.getJqGridCellText(element, 'kcmc');
                debugLog(`è¯¾ç¨‹åç§°å•å…ƒæ ¼å†…å®¹: "${text}"`);
                if (text && text.length > 1 && !/^[a-f0-9]+$/i.test(text)) {
                    return text;
                }
                
                // å¤‡ç”¨æ–¹æ¡ˆï¼šä»æ‰€æœ‰å•å…ƒæ ¼ä¸­æŸ¥æ‰¾è¯¾ç¨‹å
                const cells = element.querySelectorAll('td');
                for (let i = 0; i < cells.length; i++) {
                    const cellText = cells[i].textContent.trim();
                    
                    if (cellText && cellText.length > 1 && !/^[a-f0-9]+$/i.test(cellText)) {
                        // æ£€æŸ¥æ˜¯å¦åŒ…å«è¯¾ç¨‹ç›¸å…³å…³é”®è¯æˆ–ä¸­æ–‡
                        if (/[\u4e00-\u9fa5]{2,}/.test(cellText) &&
                            (cellText.includes('ç¨‹åºè®¾è®¡') || cellText.includes('è®¡ç®—æœº') ||
                             cellText.includes('Web') || cellText.includes('å®è®­') ||
                             cellText.includes('æ“ä½œç³»ç»Ÿ') || cellText.includes('ç”µå·¥') ||
                             cellText.includes('åŠ³åŠ¨') || cellText.includes('åµŒå…¥å¼'))) {
                            return cellText;
                        }
                    }
                }
                
                // æœ€åå¤‡ç”¨ï¼šè¿”å›ç¬¬ä¸€ä¸ªéåŠ å¯†çš„æ–‡æœ¬
                for (let i = 0; i < cells.length; i++) {
                    const cellText = cells[i].textContent.trim();
                    if (cellText && cellText.length > 1 && !/^[a-f0-9]+$/i.test(cellText) && /[\u4e00-\u9fa5]/.test(cellText)) {
                        return cellText;
                    }
                }
            } else {
                // æ™®é€šè¡¨æ ¼å¤„ç†
                const nameSelectors = this.selectors.courseCell;
               
                for (const selector of nameSelectors) {
                    const nameElement = element.querySelector(selector);
                    if (nameElement) {
                        return nameElement.textContent.trim();
                    }
                }
               
                // ä»æ–‡æœ¬ä¸­æå–
                const text = element.textContent;
                const rawLines = text.split('\n');
                const lines = [];
                for (let i = 0; i < rawLines.length; i++) {
                    const line = rawLines[i].trim();
                    if (line) {
                        lines.push(line);
                    }
                }
                return lines.length > 1 ? lines[1] : 'æœªçŸ¥è¯¾ç¨‹';
            }
            
            return 'æœªçŸ¥è¯¾ç¨‹';
        }
        
        // è·å–æ•™å¸ˆå§“å
        getTeacherName(element) {
            // æ£€æŸ¥æ˜¯å¦ä¸ºjqGridæ•°æ®è¡Œ
            const isJqGridRow = element.className.includes('ui-widget-content jqgrow');
            
            if (isJqGridRow) {
                const text = this.getJqGridCellText(element, 'jzgmc');
                debugLog(`æ•™å¸ˆå§“åå•å…ƒæ ¼å†…å®¹: "${text}"`);
                if (text && text.length > 1 && !/^[a-f0-9]+$/i.test(text)) {
                    if (/^[\u4e00-\u9fa5]{2,4}$/.test(text)) {
                        return text;
                    }
                }
                
                // å¤‡ç”¨æ–¹æ¡ˆï¼šä»æ‰€æœ‰å•å…ƒæ ¼ä¸­æŸ¥æ‰¾æ•™å¸ˆå
                const cells = element.querySelectorAll('td');
                for (let i = 0; i < cells.length; i++) {
                    const cellText = cells[i].textContent.trim();
                    
                    if (cellText && cellText.length > 1 && !/^[a-f0-9]+$/i.test(cellText)) {
                        // ä¸­æ–‡å§“åæ£€æµ‹ï¼ˆ2-4ä¸ªæ±‰å­—ï¼‰
                        if (/^[\u4e00-\u9fa5]{2,4}$/.test(cellText)) {
                            return cellText;
                        }
                    }
                }
            } else {
                // æ™®é€šè¡¨æ ¼å¤„ç†
                const secondCell = element.querySelector('td:nth-child(2)');
                if (secondCell) {
                    const teacherName = secondCell.textContent.trim();
                    if (teacherName && teacherName.length > 0) {
                        return teacherName;
                    }
                }
               
                // å¤‡ç”¨æ–¹æ¡ˆï¼šä»æ‰€æœ‰å•å…ƒæ ¼ä¸­æŸ¥æ‰¾æ•™å¸ˆå
                const cells = element.querySelectorAll('td');
                for (let i = 0; i < cells.length; i++) {
                    const cellText = cells[i].textContent.trim();
                    if (cellText && cellText.length > 1) {
                        // ä¸­æ–‡å§“åæ£€æµ‹ï¼ˆ2-4ä¸ªæ±‰å­—ï¼‰
                        if (/^[\u4e00-\u9fa5]{2,4}$/.test(cellText)) {
                            return cellText;
                        }
                    }
                }
            }
           
            return 'æœªçŸ¥æ•™å¸ˆ';
        }
        
        // è·å–è¯¾ç¨‹è¯¦ç»†ä¿¡æ¯ï¼ˆå¢å¼ºç‰ˆï¼‰
        getCourseDetails(element) {
            const isJqGridRow = element.className.includes('ui-widget-content jqgrow');
            
            if (isJqGridRow) {
                return {
                    id: this.getJqGridCellText(element, 'jxb_id'),
                    courseId: this.getJqGridCellText(element, 'kch_id'),
                    teacherId: this.getJqGridCellText(element, 'jgh_id'),
                    status: this.getCourseStatus(element),
                    teacher: this.getJqGridCellText(element, 'jzgmc'),
                    courseName: this.getJqGridCellText(element, 'kcmc'),
                    className: this.getJqGridCellText(element, 'jxbmc'),
                    courseType: this.getJqGridCellText(element, 'xsmc'),
                    operation: this.getJqGridCellText(element, 'cz')
                };
            } else {
                // æ™®é€šè¡¨æ ¼å¤„ç†
                return {
                    id: this.getElementText(element, this.selectors.courseId),
                    courseId: this.getElementText(element, this.selectors.courseId),
                    teacherId: this.getElementText(element, this.selectors.teacherId),
                    status: this.getCourseStatus(element),
                    teacher: this.getElementText(element, this.selectors.teacherName),
                    courseName: this.getElementText(element, this.selectors.courseName),
                    className: this.getElementText(element, this.selectors.className),
                    courseType: this.getElementText(element, this.selectors.courseType),
                    operation: this.getElementText(element, this.selectors.operation)
                };
            }
            
            return null;
        }
        
        // è·å–éœ€è¦è¯„ä»·çš„è¯¾ç¨‹
        async getUnevaluatedCourses() {
            const allCourses = await this.getAllCourses();
            const unevaluated = [];
            for (let i = 0; i < allCourses.length; i++) {
                const course = allCourses[i];
                const status = (course.status || '').toLowerCase();
                if (status.includes('æœªè¯„') ||
                    status.includes('å¾…è¯„') ||
                    status.includes('æœªå®Œæˆ') ||
                    status.includes('pending')) {
                    unevaluated.push(course);
                }
            }
            
            debugLog(`å…±æ‰¾åˆ° ${allCourses.length} é—¨è¯¾ç¨‹ï¼Œå…¶ä¸­ ${unevaluated.length} é—¨éœ€è¦è¯„ä»·`);
            const courseStatuses = [];
            for (let i = 0; i < allCourses.length; i++) {
                const c = allCourses[i];
                courseStatuses.push(`${c.courseName}: ${c.status}`);
            }
            debugLog('æ‰€æœ‰è¯¾ç¨‹çŠ¶æ€:', courseStatuses);
            return unevaluated;
        }
    }

    class ScoringManager {
        constructor() {
            this.scoreHistory = [];
        }

        async fillScores() {
            const scope = document.querySelector('#ajaxForm1') || document;
            const scoreButtons = scope.querySelectorAll('input[type="radio"]');
            const scoreGroups = {};

            for (let i = 0; i < scoreButtons.length; i++) {
                const button = scoreButtons[i];
                if (!button) continue;
                const name = button.name || button.getAttribute('name');
                if (!name) continue;
                if (!scoreGroups[name]) scoreGroups[name] = [];
                scoreGroups[name].push(button);
            }

            const groupNames = Object.keys(scoreGroups);
            debugLog(`æ‰¾åˆ° ${groupNames.length} ä¸ªè¯„åˆ†ç»„`);

            for (let i = 0; i < groupNames.length; i++) {
                if (!isRunning) return false;
                await checkPause();
                if (!isRunning) return false;

                const groupName = groupNames[i];
                const buttons = scoreGroups[groupName] || [];
                const isLastGroup = i === groupNames.length - 1;
                const targetScore = isLastGroup ? config.lastItemScore : config.defaultScore;

                const targetButton = this.pickBestRadio(buttons, targetScore, isLastGroup);
                if (targetButton) {
                    try {
                        targetButton.scrollIntoView({ behavior: 'instant', block: 'center' });
                    } catch (e) {}
                    await interruptibleSleep(80);  // ä»200msä¼˜åŒ–åˆ°80ms
                    if (!isRunning) return false;

                    targetButton.click();
                    const selectedScore = this.getRadioScore(targetButton);
                    this.scoreHistory.push({ groupName, value: targetButton.value, score: selectedScore });
                    debugLog('è¯„åˆ†é€‰æ‹©', { groupName, targetScore, selectedScore, value: targetButton.value });
                    await interruptibleSleep(config.delayBetweenActions);
                }
            }

            return groupNames.length > 0;
        }

        isRadioUsable(btn) {
            if (!btn) return false;
            if (btn.disabled) return false;
            try {
                const ariaDisabled = btn.getAttribute && btn.getAttribute('aria-disabled');
                if (ariaDisabled === 'true') return false;
            } catch (e) {}
            return true;
        }

        getRadioScore(btn) {
            if (!btn) return NaN;

            const texts = [];

            try {
                if (btn.labels && btn.labels.length) {
                    for (let i = 0; i < btn.labels.length; i++) {
                        const label = btn.labels[i];
                        if (label && label.textContent) texts.push(label.textContent);
                    }
                }
            } catch (e) {}

            try {
                const parentLabel = btn.closest && btn.closest('label');
                if (parentLabel && parentLabel.textContent) texts.push(parentLabel.textContent);
            } catch (e) {}

            try {
                const next = btn.nextElementSibling;
                if (next && next.textContent) texts.push(next.textContent);
            } catch (e) {}

            try {
                const td = btn.closest && btn.closest('td');
                if (td && td.textContent) texts.push(td.textContent);
            } catch (e) {}

            const combined = texts.join(' ').replace(/\s+/g, ' ').trim();
            if (!combined) return NaN;

            const match = combined.match(/\b(100|90|80|70|60|50)\b/);
            if (!match) return NaN;
            const score = parseInt(match[1], 10);
            if (!Number.isFinite(score)) return NaN;
            return score;
        }

        pickBestRadio(buttons, targetScore, isLastGroup) {
            if (!buttons || buttons.length === 0) return null;

            const usable = [];
            for (let i = 0; i < buttons.length; i++) {
                const btn = buttons[i];
                if (!this.isRadioUsable(btn)) continue;
                usable.push(btn);
            }
            if (usable.length === 0) return null;

            const targetStr = String(targetScore);
            for (let i = 0; i < usable.length; i++) {
                const btn = usable[i];
                if (!btn) continue;
                if (String(btn.value) === targetStr) return btn;
            }

            const scored = [];
            for (let i = 0; i < usable.length; i++) {
                const btn = usable[i];
                const score = this.getRadioScore(btn);
                if (Number.isFinite(score)) {
                    scored.push({ btn, score, idx: i });
                }
            }

            if (scored.length > 0) {
                for (let i = 0; i < scored.length; i++) {
                    if (scored[i].score === targetScore) return scored[i].btn;
                }

                if (targetScore === config.defaultScore) {
                    let best = scored[0].btn;
                    let bestScore = scored[0].score;
                    for (let i = 1; i < scored.length; i++) {
                        if (scored[i].score > bestScore) {
                            best = scored[i].btn;
                            bestScore = scored[i].score;
                        }
                    }
                    return best;
                }

                if (targetScore === config.lastItemScore) {
                    let bestBelow = null;
                    let bestBelowScore = -Infinity;
                    let bestAbove = null;
                    let bestAboveScore = Infinity;

                    for (let i = 0; i < scored.length; i++) {
                        const item = scored[i];
                        if (item.score <= targetScore && item.score > bestBelowScore) {
                            bestBelow = item.btn;
                            bestBelowScore = item.score;
                        }
                        if (item.score >= targetScore && item.score < bestAboveScore) {
                            bestAbove = item.btn;
                            bestAboveScore = item.score;
                        }
                    }

                    if (bestBelow) return bestBelow;
                    if (bestAbove) return bestAbove;
                }

                return scored[0].btn;
            }

            if (targetScore === config.defaultScore) return usable[0];
            if (targetScore === config.lastItemScore) return usable.length > 1 ? usable[1] : usable[0];
            return usable[0];
        }
    }

    class CommentGenerator {
        constructor() {
            this.usedComments = new Set();
        }

        async fillComments() {
            const scope = document.querySelector('#ajaxForm1') || document;
            const textareas = scope.querySelectorAll('textarea');
            debugLog(`æ‰¾åˆ° ${textareas.length} ä¸ªè¯„è¯­æ–‡æœ¬æ¡†`);

            for (let i = 0; i < textareas.length; i++) {
                if (!isRunning) return false;
                await checkPause();
                if (!isRunning) return false;

                const textarea = textareas[i];
                if (!textarea) continue;

                const existing = (textarea.value || '').trim();
                if (existing && existing.length >= 5) continue;

                const comment = this.generateComment();
                await this.fastFillText(textarea, comment);  // ä½¿ç”¨å¿«é€Ÿå¡«å……æ›¿ä»£é€å­—è¾“å…¥
                await interruptibleSleep(config.delayBetweenActions);
            }

            return textareas.length > 0;
        }

        generateComment() {
            // 70%æ¦‚ç‡ä½¿ç”¨éšæœºç»„åˆï¼Œ30%æ¦‚ç‡ä½¿ç”¨æ¨¡æ¿
            const useRandomCombo = Math.random() < 0.7;
            let selectedComment;
            
            if (useRandomCombo) {
                // éšæœºç»„åˆç”Ÿæˆï¼ˆå¯äº§ç”Ÿ 15*15*15 = 3375 ç§ç»„åˆï¼‰
                selectedComment = generateRandomComment();
            } else {
                // ä½¿ç”¨é¢„è®¾æ¨¡æ¿
                let attempts = 0;
                const maxAttempts = commentTemplates.length;
                selectedComment = commentTemplates[0];

                while (attempts < maxAttempts) {
                    const randomIndex = Math.floor(Math.random() * commentTemplates.length);
                    const candidate = commentTemplates[randomIndex];
                    if (!this.usedComments.has(candidate)) {
                        selectedComment = candidate;
                        break;
                    }
                    attempts++;
                }
            }

            selectedComment = this.adjustCommentLength(selectedComment);
            this.usedComments.add(selectedComment);
            return selectedComment;
        }

        adjustCommentLength(comment) {
            if (comment.length < config.minCommentLength) {
                return comment + 'æ•™å­¦æ•ˆæœå¾ˆå¥½ã€‚';
            }
            if (comment.length > config.maxCommentLength) {
                return comment.substring(0, config.maxCommentLength - 1) + 'ã€‚';
            }
            return comment;
        }

        // å¿«é€Ÿå¡«å……æ–‡æœ¬ - ä¼˜åŒ–ç‰ˆæœ¬ï¼Œç›´æ¥è®¾ç½®å€¼
        async fastFillText(element, text) {
            try {
                element.focus();
            } catch (e) {}

            element.value = text;
            element.dispatchEvent(new Event('input', { bubbles: true }));
            element.dispatchEvent(new Event('change', { bubbles: true }));
            
            await sleep(50);  // çŸ­æš‚ç­‰å¾…ç¡®ä¿äº‹ä»¶å¤„ç†å®Œæˆ
        }

        // ä¿ç•™åŸå§‹é€å­—è¾“å…¥æ–¹æ³•ï¼ˆå¤‡ç”¨ï¼‰
        async simulateTyping(element, text) {
            try {
                element.focus();
            } catch (e) {}

            element.value = '';
            element.dispatchEvent(new Event('input', { bubbles: true }));

            for (let i = 0; i < text.length; i++) {
                if (!isRunning) break;
                await checkPause();
                if (!isRunning) break;

                element.value += text[i];
                element.dispatchEvent(new Event('input', { bubbles: true }));

                const delay = config.typingDelay + Math.random() * 30;
                await sleep(delay);
            }
        }
    }

    class SaveManager {
        isClickableButton(element) {
            if (!element) return false;
            
            const isSave = this.isSaveButton(element);
            if (!isSave) return false;
            
            try {
                if (element.disabled) {
                    debugLog(`ğŸ” æŒ‰é’®è¢«ç¦ç”¨: ${element.id || element.textContent}`);
                    return false;
                }
                const ariaDisabled = element.getAttribute && element.getAttribute('aria-disabled');
                if (ariaDisabled === 'true') {
                    debugLog(`ğŸ” æŒ‰é’® aria-disabled=true: ${element.id || element.textContent}`);
                    return false;
                }
            } catch (e) {}
            
            const visible = isLikelyVisible(element);
            
            // ç‰¹æ®Šå¤„ç†ï¼šå¯¹äº btn_xspj_bcï¼Œå³ä½¿å¯è§æ€§æ£€æŸ¥å¤±è´¥ä¹Ÿè¿”å› true
            if (!visible && element.id === 'btn_xspj_bc') {
                debugLog('âš ï¸ btn_xspj_bc å¯è§æ€§æ£€æŸ¥å¤±è´¥ï¼Œä½†å¼ºåˆ¶è¿”å›å¯ç‚¹å‡»');
                return true;
            }
            
            return visible;
        }

        getSelectedCourseRow() {
            try {
                return document.querySelector('tr.ui-widget-content.jqgrow[aria-selected="true"], tr.ui-widget-content.jqgrow.ui-state-highlight');
            } catch (e) {
                return null;
            }
        }

        findCourseRowByName(courseName) {
            if (!courseName) return null;
            const rows = document.querySelectorAll('#tempGrid tr.ui-widget-content.jqgrow');
            const len = typeof rows.length === 'number' ? rows.length : 0;
            for (let i = 0; i < len; i++) {
                const row = rows[i];
                if (!row) continue;
                const td = row.querySelector('td[aria-describedby="tempGrid_kcmc"]');
                const text = td ? (td.getAttribute('title') || td.textContent || '').trim() : '';
                if (text && String(text).indexOf(String(courseName)) >= 0) return row;
            }
            return null;
        }

        getRowStatusText(row) {
            if (!row) return '';
            const td = row.querySelector('td[aria-describedby="tempGrid_tjztmc"]');
            return td ? ((td.getAttribute('title') || td.textContent || '').trim()) : '';
        }

        isSavedStatusText(text) {
            if (!text) return false;
            return text.indexOf('ä¿å­˜') >= 0 || text.indexOf('å·²è¯„') >= 0 || text.indexOf('å®Œæˆ') >= 0;
        }

        findBestSaveButton(scope) {
            debugLog('ğŸ” å¼€å§‹æŸ¥æ‰¾ä¿å­˜æŒ‰é’®...');
            const doc = document;
            const directIds = ['btn_xspj_bc', 'btn_bc'];
            
            // é¦–å…ˆæ£€æŸ¥æ‰€æœ‰å·²çŸ¥IDçš„æŒ‰é’®
            for (let i = 0; i < directIds.length; i++) {
                const id = directIds[i];
                const el = doc.getElementById(id);
                
                debugLog(`ğŸ” æ£€æŸ¥æŒ‰é’® #${id}`, {
                    å­˜åœ¨: !!el,
                    tagName: el ? el.tagName : 'æ— ',
                    disabled: el ? el.disabled : 'æ— ',
                    textContent: el ? (el.textContent || '').trim().substring(0, 20) : 'æ— '
                });
                
                if (el) {
                    const isClickable = this.isClickableButton(el);
                    debugLog(`ğŸ” æŒ‰é’® #${id} å¯ç‚¹å‡»æ€§æ£€æŸ¥`, { isClickable });
                    
                    if (!isClickable) {
                        // è¯¦ç»†åˆ†æä¸ºä»€ä¹ˆä¸å¯ç‚¹å‡»
                        this.analyzeButtonClickability(el, id);
                    } else {
                        debugLog(`âœ… æ‰¾åˆ°å¯ç‚¹å‡»çš„ä¿å­˜æŒ‰é’®: #${id}`);
                        return el;
                    }
                }
            }

            debugLog('âš ï¸ ç›´æ¥IDæŸ¥æ‰¾å¤±è´¥ï¼Œå°è¯•éå†æŸ¥æ‰¾...');
            
            const candidateScopes = [];
            if (scope && scope !== doc) candidateScopes.push(scope);
            candidateScopes.push(doc);

            for (let s = 0; s < candidateScopes.length; s++) {
                const root = candidateScopes[s];
                let nodes = [];
                try {
                    nodes = root.querySelectorAll('button, input[type="button"], input[type="submit"], a');
                } catch (e) {
                    nodes = [];
                }

                debugLog(`ğŸ” åœ¨ scope[${s}] ä¸­æ‰¾åˆ° ${nodes.length} ä¸ªæŒ‰é’®å…ƒç´ `);
                
                const len = typeof nodes.length === 'number' ? nodes.length : 0;
                for (let i = 0; i < len; i++) {
                    const el = nodes[i];
                    if (this.isClickableButton(el)) {
                        debugLog(`âœ… éå†æ‰¾åˆ°å¯ç‚¹å‡»çš„ä¿å­˜æŒ‰é’®`, {
                            id: el.id || 'æ— ',
                            text: (el.textContent || '').trim().substring(0, 20)
                        });
                        return el;
                    }
                }
            }

            debugLog('âŒ æœªæ‰¾åˆ°ä»»ä½•å¯ç‚¹å‡»çš„ä¿å­˜æŒ‰é’®');
            return null;
        }
        
        // åˆ†ææŒ‰é’®ä¸ºä»€ä¹ˆä¸å¯ç‚¹å‡»
        analyzeButtonClickability(el, id) {
            debugLog(`ğŸ”¬ åˆ†ææŒ‰é’® #${id} ä¸å¯ç‚¹å‡»çš„åŸå› :`);
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯ä¿å­˜æŒ‰é’®
            const isSave = this.isSaveButton(el);
            debugLog(`   - isSaveButton: ${isSave}`);
            
            // æ£€æŸ¥ disabled å±æ€§
            debugLog(`   - disabled: ${el.disabled}`);
            
            // æ£€æŸ¥ aria-disabled
            const ariaDisabled = el.getAttribute && el.getAttribute('aria-disabled');
            debugLog(`   - aria-disabled: ${ariaDisabled}`);
            
            // æ£€æŸ¥å¯è§æ€§
            const visible = isLikelyVisible(el);
            debugLog(`   - isLikelyVisible: ${visible}`);
            
            // è¯¦ç»†çš„å¯è§æ€§åˆ†æ
            try {
                const style = window.getComputedStyle(el);
                debugLog(`   - display: ${style.display}`);
                debugLog(`   - visibility: ${style.visibility}`);
                debugLog(`   - opacity: ${style.opacity}`);
                
                const rect = el.getBoundingClientRect();
                debugLog(`   - å°ºå¯¸: ${rect.width}x${rect.height}`);
                debugLog(`   - ä½ç½®: top=${rect.top}, left=${rect.left}`);
            } catch (e) {
                debugLog(`   - æ ·å¼è·å–å¤±è´¥: ${e.message}`);
            }
            
            // æ£€æŸ¥çˆ¶å…ƒç´ 
            try {
                let parent = el.parentElement;
                let level = 0;
                while (parent && level < 5) {
                    const parentStyle = window.getComputedStyle(parent);
                    if (parentStyle.display === 'none') {
                        debugLog(`   - çˆ¶å…ƒç´ [${level}] display:none`, {
                            tagName: parent.tagName,
                            id: parent.id || 'æ— ',
                            className: (parent.className || '').substring(0, 30)
                        });
                        break;
                    }
                    parent = parent.parentElement;
                    level++;
                }
            } catch (e) {}
        }

        async clickSaveButton(button) {
            // ä½¿ç”¨ç®€å•ç‰ˆæœ¬ç‚¹å‡»æŒ‰é’®
            return await this.clickSaveButtonSimple(button);
        }

        tryHandleSaveSuccessDialogOnce() {
            // ç»Ÿä¸€ä½¿ç”¨ findAndConfirmInjectionWarningOnce å¤„ç†æ‰€æœ‰å¼¹çª—
            return findAndConfirmInjectionWarningOnce();
        }

        async waitForSaveResult(courseInfo, beforeStatus) {
            const maxWait = 8000;   // ä»12ç§’ä¼˜åŒ–åˆ°8ç§’
            const step = 100;       // ä»150msä¼˜åŒ–åˆ°100ms
            let elapsed = 0;
            let dialogHandledCount = 0;

            debugLog('å¼€å§‹ç­‰å¾…ä¿å­˜ç»“æœ', { beforeStatus, courseName: courseInfo && courseInfo.courseName });

            const row = this.getSelectedCourseRow() || this.findCourseRowByName(courseInfo && courseInfo.courseName);
            while (elapsed < maxWait) {
                if (!isRunning) return false;

                // ç§¯ææ£€æµ‹å¹¶å¤„ç†å¼¹çª—ï¼ˆå¯èƒ½æœ‰å¤šä¸ªå¼¹çª—éœ€è¦å¤„ç†ï¼‰
                try {
                    if (findAndConfirmInjectionWarningOnce()) {
                        dialogHandledCount++;
                        debugLog('waitForSaveResult: å·²å¤„ç†å¼¹çª—', { count: dialogHandledCount });
                        // å¤„ç†å¼¹çª—åç­‰å¾…ä¸€å°æ®µæ—¶é—´è®©é¡µé¢æ›´æ–° - å·²ä¼˜åŒ–
                        await interruptibleSleep(300);
                        // ç»§ç»­æ£€æµ‹ï¼Œä¸å¢åŠ  elapsedï¼Œå› ä¸ºå¯èƒ½è¿˜æœ‰å¼¹çª—
                        continue;
                    }
                } catch (e) {}

                // æ£€æŸ¥è¯¾ç¨‹çŠ¶æ€æ˜¯å¦å˜ä¸ºå·²è¯„
                const currentRow = row || this.getSelectedCourseRow() || this.findCourseRowByName(courseInfo && courseInfo.courseName);
                const status = this.getRowStatusText(currentRow);
                
                // æ¯2ç§’è¾“å‡ºä¸€æ¬¡çŠ¶æ€æ£€æµ‹æ—¥å¿—
                if (elapsed % 2000 < step) {
                    debugLog('çŠ¶æ€æ£€æµ‹ä¸­', { elapsed, status, beforeStatus, dialogHandledCount });
                }
                
                if (status) {
                    // æ£€æŸ¥æ˜¯å¦ä¸ºå·²è¯„çŠ¶æ€
                    if (this.isSavedStatusText(status)) {
                        // å¦‚æœçŠ¶æ€å‘ç”Ÿäº†å˜åŒ–ï¼Œæˆ–è€…å·²ç»å¤„ç†è¿‡å¼¹çª—
                        if ((!beforeStatus || status !== beforeStatus) || dialogHandledCount > 0) {
                            debugLog('æ£€æµ‹åˆ°ä¿å­˜ç»“æœçŠ¶æ€å˜æ›´', { beforeStatus, status, dialogHandledCount });
                            return true;
                        }
                    }
                }

                await interruptibleSleep(step);
                elapsed += step;
            }
            
            // è¶…æ—¶åå†æ£€æŸ¥ä¸€æ¬¡çŠ¶æ€
            const finalRow = this.getSelectedCourseRow() || this.findCourseRowByName(courseInfo && courseInfo.courseName);
            const finalStatus = this.getRowStatusText(finalRow);
            if (finalStatus && this.isSavedStatusText(finalStatus)) {
                debugLog('è¶…æ—¶åæ£€æµ‹åˆ°å·²è¯„çŠ¶æ€', { finalStatus });
                return true;
            }
            
            debugLog('ç­‰å¾…ä¿å­˜ç»“æœè¶…æ—¶', { beforeStatus, finalStatus, dialogHandledCount });
            return false;
        }

        async saveEvaluation(courseInfo = null) {
            if (!isRunning) return false;

            // ä¿å­˜å‰ç­‰å¾…ï¼ˆå¸¦æš‚åœæ„ŸçŸ¥ï¼‰
            if (config.preSaveWaitTime > 0) {
                debugLog(`ä¿å­˜å‰ç­‰å¾… ${config.preSaveWaitTime / 1000} ç§’`);
                const waitResult = await pauseAwareWait(config.preSaveWaitTime, (state) => {
                    if (state.paused) {
                        updateStatus(`ä¿å­˜å‰ç­‰å¾…: ${state.remaining}ç§’ (å·²æš‚åœ)`);
                    } else {
                        updateStatus(`ä¿å­˜å‰ç­‰å¾…: ${state.remaining}ç§’`);
                    }
                });
                
                // ç­‰å¾…å®Œæˆåæ¸…é™¤å€’è®¡æ—¶æ˜¾ç¤º
                updateStatus('æ­£åœ¨ä¿å­˜è¯„ä»·...');
                
                if (!waitResult) {
                    debugLog('ä¿å­˜å‰ç­‰å¾…è¢«ä¸­æ–­');
                    return false;
                }
            }

            const scope = document.querySelector('#ajaxForm1') || document;

            const row = this.getSelectedCourseRow() || this.findCourseRowByName(courseInfo && courseInfo.courseName);
            const beforeStatus = this.getRowStatusText(row);

            const maxRetries = config.maxRetries || 3;
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                if (!isRunning) return false;
                await checkPause();
                if (!isRunning) return false;

                // æ‰§è¡Œä¿å­˜æ“ä½œï¼ˆåŒ…å«å¼¹çª—å¤„ç†å’Œé‡è¯•é€»è¾‘ï¼‰
                const saveResult = await this.doSaveWithDialogHandling(scope, courseInfo, beforeStatus);
                if (saveResult) return true;
                
                debugLog('ä¿å­˜éªŒè¯æœªé€šè¿‡ï¼Œå‡†å¤‡é‡è¯•', { attempt, maxRetries });
                await interruptibleSleep(500);  // ä»800msä¼˜åŒ–åˆ°500ms
            }

            return false;
        }
        
        // æ‰§è¡Œä¿å­˜æ“ä½œï¼Œå¤„ç†å¼¹çª—å¹¶éªŒè¯ç»“æœ
        // æ ¸å¿ƒç­–ç•¥ï¼šåœæ­¢è‡ªåŠ¨å¼¹çª—å¤„ç† â†’ ç‚¹å‡»ä¿å­˜ â†’ æ‰‹åŠ¨å¤„ç†å¼¹çª— â†’ éªŒè¯ç»“æœ
        async doSaveWithDialogHandling(scope, courseInfo, beforeStatus) {
            debugLog('========== å¼€å§‹æ‰§è¡Œä¿å­˜æ“ä½œ ==========');
            debugLog('ğŸ“‹ è¯¾ç¨‹ä¿¡æ¯', { 
                courseName: courseInfo ? courseInfo.courseName : 'æ— ',
                beforeStatus 
            });
            
            // é‡ç½®ä¿å­˜è¯·æ±‚æ ‡è®°ï¼Œå…è®¸æœ¬æ¬¡ä¿å­˜å‘é€è¯·æ±‚
            window._bypassSaveRequestSent = false;
            window._injectionBypassSaveSuccess = false;
            
            // ========== ç¬¬ä¸€æ­¥ï¼šåœæ­¢ MutationObserver ==========
            stopInjectionWarningAutoCloser();
            debugLog('âœ… å·²åœæ­¢è‡ªåŠ¨å¼¹çª—å¤„ç†');
            
            try {
                // ========== ç¬¬äºŒæ­¥ï¼šè·å–ä¿å­˜æŒ‰é’® ==========
                debugLog('ğŸ” ç¬¬äºŒæ­¥ï¼šæŸ¥æ‰¾ä¿å­˜æŒ‰é’®');
                
                // å…ˆåˆ—å‡ºé¡µé¢ä¸Šæ‰€æœ‰åŒ…å«"ä¿å­˜"æ–‡å­—çš„æŒ‰é’®
                try {
                    const allButtons = document.querySelectorAll('button, input[type="button"]');
                    const saveButtons = [];
                    for (let i = 0; i < allButtons.length; i++) {
                        const btn = allButtons[i];
                        const text = (btn.textContent || btn.value || '').trim();
                        if (text.indexOf('ä¿å­˜') >= 0) {
                            saveButtons.push({
                                id: btn.id || 'æ— ID',
                                text: text.substring(0, 20),
                                visible: isLikelyVisible(btn),
                                disabled: btn.disabled
                            });
                        }
                    }
                    debugLog('ğŸ“‹ é¡µé¢ä¸Šæ‰€æœ‰ä¿å­˜æŒ‰é’®', saveButtons);
                } catch (e) {}
                
                let button = document.getElementById('btn_xspj_bc');
                debugLog('ğŸ” ç›´æ¥è·å– btn_xspj_bc', { 
                    found: !!button,
                    id: button ? button.id : 'æ— ',
                    visible: button ? isLikelyVisible(button) : false
                });
                
                if (!button) {
                    debugLog('âš ï¸ btn_xspj_bc ä¸å­˜åœ¨ï¼Œå°è¯• findBestSaveButton');
                    button = this.findBestSaveButton(scope);
                }
                
                if (!button) {
                    debugLog('âŒ æœªæ‰¾åˆ°ä»»ä½•å¯ç‚¹å‡»çš„ä¿å­˜æŒ‰é’®');
                    return false;
                }

                debugLog('âœ… æ‰¾åˆ°ä¿å­˜æŒ‰é’®', { 
                    id: button.id || 'æ— ID', 
                    text: (button.textContent || '').trim().substring(0, 30),
                    tagName: button.tagName
                });
                
                // ========== ç¬¬ä¸‰æ­¥ï¼šç‚¹å‡»ä¿å­˜æŒ‰é’® ==========
                window._needBypassSave = false;  // é‡ç½®æ ‡è®°
                const clickResult = await this.clickSaveButtonSimple(button);
                debugLog('âœ… å·²ç‚¹å‡»ä¿å­˜æŒ‰é’®');
                
                // æ£€æŸ¥æ˜¯å¦è§¦å‘äº†è„šæœ¬æ³¨å…¥è­¦å‘Šï¼ˆè¢«æ‹¦æˆªï¼‰
                if (window._needBypassSave) {
                    debugLog('ğŸ”„ æ£€æµ‹åˆ°è„šæœ¬æ³¨å…¥è­¦å‘Šè¢«æ‹¦æˆªï¼Œç›´æ¥å‘é€ AJAX ä¿å­˜è¯·æ±‚...');
                    
                    try {
                        const saveUrl = '/jwglxt/xspjgl/xspj_bcXspj.html?gnmkdm=N401605';
                        const formData = jQuery('#ajaxForm1').serialize();
                        debugLog('ğŸ“¤ å‘é€ä¿å­˜è¯·æ±‚...', { dataLength: formData.length });
                        
                        const ajaxResult = await new Promise((resolve) => {
                            jQuery.ajax({
                                url: saveUrl,
                                type: 'POST',
                                data: formData,
                                dataType: 'text',
                                success: function(response) {
                                    debugLog('âœ… ç»•è¿‡ä¿å­˜è¯·æ±‚æˆåŠŸ', response);
                                    resolve({ success: true, response });
                                },
                                error: function(xhr, status, error) {
                                    debugLog('âŒ ç»•è¿‡ä¿å­˜è¯·æ±‚å¤±è´¥', { status, error });
                                    resolve({ success: false, error });
                                }
                            });
                        });
                        
                        if (ajaxResult.success) {
                            // ç­‰å¾…æœåŠ¡å™¨å¤„ç† - å·²ä¼˜åŒ–
                            await sleep(800);
                            const verified = await this.verifySaveSuccess(courseInfo, beforeStatus);
                            if (verified) {
                                debugLog('ğŸ‰ ç»•è¿‡ä¿å­˜æˆåŠŸï¼ŒçŠ¶æ€å·²å˜æ›´');
                                return true;
                            } else {
                                debugLog('âš ï¸ ç»•è¿‡ä¿å­˜è¿”å›æˆåŠŸä½†çŠ¶æ€æœªå˜æ›´');
                            }
                        }
                    } catch (e) {
                        debugLog('âŒ ç»•è¿‡ä¿å­˜å¼‚å¸¸', e.message);
                    }
                }
                
                // å¦‚æœ AJAX ç›´æ¥ä¿å­˜å£°ç§°æˆåŠŸï¼Œéœ€è¦éªŒè¯çŠ¶æ€æ˜¯å¦çœŸçš„å˜äº†
                if (clickResult === true) {
                    debugLog('ğŸ” AJAX è¿”å›æˆåŠŸï¼ŒéªŒè¯çŠ¶æ€æ˜¯å¦çœŸçš„å˜æ›´...');
                    await sleep(600);  // ä»1000msä¼˜åŒ–åˆ°600ms
                    const verified = await this.verifySaveSuccess(courseInfo, beforeStatus);
                    if (verified) {
                        debugLog('ğŸ‰ AJAX ä¿å­˜éªŒè¯é€šè¿‡ï¼ŒçŠ¶æ€å·²å˜æ›´');
                        return true;
                    } else {
                        debugLog('âš ï¸ AJAX è¿”å›æˆåŠŸä½†çŠ¶æ€æœªå˜æ›´ï¼Œå¯èƒ½æ˜¯å‡æˆåŠŸï¼Œç»§ç»­å°è¯•å…¶ä»–æ–¹å¼...');
                        // ä¸ç›´æ¥è¿”å›ï¼Œç»§ç»­èµ°å¼¹çª—æ£€æµ‹æµç¨‹
                    }
                }
                
                // ========== ç¬¬å››æ­¥ï¼šç«‹å³å¼€å§‹æ£€æµ‹å¼¹çª—ï¼ˆç§»é™¤åˆå§‹ç­‰å¾…ï¼‰==========
                let saveSuccess = false;
                let injectionWarningHandled = false;
                
                // å¾ªç¯æ£€æµ‹å¼¹çª—ï¼ˆæœ€å¤š 4 ç§’ï¼Œæ¯ 50ms æ£€æµ‹ä¸€æ¬¡ï¼‰- æé€Ÿä¼˜åŒ–
                const maxChecks = 80;    // 4ç§’ / 50ms = 80æ¬¡
                const checkInterval = 50; // ä»100msä¼˜åŒ–åˆ°50ms
                
                debugLog(`ğŸ” å¼€å§‹æ£€æµ‹å¼¹çª—ï¼ˆæœ€å¤š ${maxChecks} æ¬¡ï¼Œé—´éš” ${checkInterval}msï¼‰`);
                
                for (let i = 0; i < maxChecks; i++) {
                    if (!isRunning) return false;
                    
                    // æ£€æµ‹å¼¹çª—
                    const dialogInfo = this.findVisibleDialog();
                    
                    // æ¯ 20 æ¬¡æ£€æµ‹è¾“å‡ºä¸€æ¬¡æ—¥å¿—ï¼ˆçº¦1ç§’ä¸€æ¬¡ï¼‰
                    if (i % 20 === 0 && i > 0) {
                        debugLog(`ğŸ” å¼¹çª—æ£€æµ‹ä¸­... (å·²ç­‰å¾… ${(i * checkInterval / 1000).toFixed(1)}ç§’)`);
                    }
                    
                    if (dialogInfo.found) {
                        debugLog('âœ… æ£€æµ‹åˆ°å¼¹çª—', { 
                            type: dialogInfo.type, 
                            text: dialogInfo.text.substring(0, 60),
                            è€—æ—¶: `${i * checkInterval}ms`
                        });
                        
                        const dialogElement = dialogInfo.dialog;
                        
                        // ç«‹å³ç‚¹å‡»ç¡®è®¤æŒ‰é’®
                        if (tryClickConfirmInDialog(dialogElement)) {
                            debugLog('âœ… å·²ç‚¹å‡»å¼¹çª—ç¡®è®¤æŒ‰é’®');
                            
                            // æ–¹æ¡ˆä¸‰ï¼šæˆåŠŸå¼¹çª—ç›´æ¥è¿”å›ï¼Œä¸ç­‰å¾…
                            if (dialogInfo.type === 'success') {
                                saveSuccess = true;
                                debugLog('ğŸ‰ æ£€æµ‹åˆ°æˆåŠŸå¼¹çª—ï¼Œä¿å­˜æˆåŠŸï¼');
                                break;
                            }
                            
                            // æ–¹æ¡ˆä¸€ï¼šç›‘å¬å¼¹çª—æ¶ˆå¤±ï¼Œè€Œéå›ºå®šç­‰å¾…
                            await this.waitForDialogClose(dialogElement);
                            
                            if (dialogInfo.type === 'injection_warning') {
                                injectionWarningHandled = true;
                                debugLog('âš ï¸ å¤„ç†äº†è„šæœ¬æ³¨å…¥è­¦å‘Š');
                                
                                // æ£€æŸ¥ä¿å­˜æ˜¯å¦æˆåŠŸ
                                const verified = await this.verifySaveSuccess(courseInfo, beforeStatus);
                                if (verified) {
                                    debugLog('âœ… ä¿å­˜å·²æˆåŠŸï¼ˆçŠ¶æ€å·²å˜æ›´ï¼‰');
                                    saveSuccess = true;
                                    break;
                                }
                            }
                        }
                    }
                    
                    await sleep(checkInterval);
                }
                
                debugLog(`ğŸ” å¼¹çª—æ£€æµ‹ç»“æŸï¼ŒsaveSuccess=${saveSuccess}`);
                
                // ========== ç¬¬äº”æ­¥ï¼šå¿«é€Ÿæ¸…ç†æ®‹ç•™å¼¹çª— ==========
                for (let i = 0; i < 3; i++) {
                    const dialogInfo = this.findVisibleDialog();
                    if (dialogInfo.found) {
                        tryClickConfirmInDialog(dialogInfo.dialog);
                        await sleep(100);
                    } else {
                        break;
                    }
                }
                
                // ========== ç¬¬å…­æ­¥ï¼šéªŒè¯ç»“æœ ==========
                if (saveSuccess) {
                    debugLog('ä¿å­˜æˆåŠŸï¼ˆé€šè¿‡æˆåŠŸå¼¹çª—ç¡®è®¤ï¼‰');
                    return true;
                }
                
                // å¦‚æœå¤„ç†è¿‡è­¦å‘Šå¼¹çª—ï¼Œå°è¯•éªŒè¯çŠ¶æ€
                if (injectionWarningHandled) {
                    debugLog('å°è¯•éªŒè¯ä¿å­˜çŠ¶æ€...');
                    await sleep(500);
                    const verified = await this.verifySaveSuccess(courseInfo, beforeStatus);
                    if (verified) {
                        debugLog('ä¿å­˜æˆåŠŸï¼ˆé€šè¿‡çŠ¶æ€éªŒè¯ç¡®è®¤ï¼‰');
                        return true;
                    }
                }
                
                debugLog('ä¿å­˜å¤±è´¥');
                return false;
                
            } finally {
                // ========== æœ€åï¼šé‡æ–°å¯åŠ¨ MutationObserver ==========
                startInjectionWarningAutoCloser();
                debugLog('å·²é‡æ–°å¯åŠ¨è‡ªåŠ¨å¼¹çª—å¤„ç†');
            }
        }
        
        // ç®€å•çš„ç‚¹å‡»ä¿å­˜æŒ‰é’®ï¼ˆä¸åšå¼¹çª—æ£€æµ‹ï¼‰
        async clickSaveButtonSimple(button) {
            if (!button) {
                debugLog('âŒ clickSaveButtonSimple: æŒ‰é’®ä¸ºç©º');
                return false;
            }

            // ========== è¯¦ç»†è°ƒè¯•ä¿¡æ¯ ==========
            debugLog('ğŸ” æŒ‰é’®è¯¦ç»†ä¿¡æ¯', {
                id: button.id || 'æ— ID',
                className: button.className || 'æ— class',
                tagName: button.tagName,
                textContent: (button.textContent || '').trim().substring(0, 30),
                disabled: button.disabled,
                type: button.type || 'æ— type'
            });
            
            // æ£€æŸ¥æŒ‰é’®çš„å¯è§æ€§
            try {
                const rect = button.getBoundingClientRect();
                const style = window.getComputedStyle(button);
                debugLog('ğŸ” æŒ‰é’®ä½ç½®å’Œæ ·å¼', {
                    ä½ç½®: `top=${rect.top}, left=${rect.left}, width=${rect.width}, height=${rect.height}`,
                    display: style.display,
                    visibility: style.visibility,
                    opacity: style.opacity,
                    pointerEvents: style.pointerEvents
                });
                
                // æ£€æŸ¥æŒ‰é’®æ˜¯å¦åœ¨è§†å£å†…
                const inViewport = rect.top >= 0 && rect.left >= 0 && 
                                   rect.bottom <= window.innerHeight && 
                                   rect.right <= window.innerWidth;
                debugLog('ğŸ” æŒ‰é’®æ˜¯å¦åœ¨è§†å£å†…', inViewport);
                
                // æ£€æŸ¥æŒ‰é’®æ˜¯å¦è¢«é®æŒ¡
                const elementAtPoint = document.elementFromPoint(
                    rect.left + rect.width / 2, 
                    rect.top + rect.height / 2
                );
                if (elementAtPoint !== button) {
                    debugLog('âš ï¸ æŒ‰é’®å¯èƒ½è¢«é®æŒ¡', {
                        é®æŒ¡å…ƒç´ : elementAtPoint ? elementAtPoint.tagName : 'æ— ',
                        é®æŒ¡å…ƒç´ ID: elementAtPoint ? elementAtPoint.id : 'æ— ',
                        é®æŒ¡å…ƒç´ class: elementAtPoint ? elementAtPoint.className : 'æ— '
                    });
                }
            } catch (e) {
                debugLog('âŒ è·å–æŒ‰é’®ä½ç½®ä¿¡æ¯å¤±è´¥', e.message);
            }
            
            // æ£€æŸ¥çˆ¶å…ƒç´ æ˜¯å¦éšè—
            try {
                let parent = button.parentElement;
                let hiddenParent = null;
                while (parent) {
                    const parentStyle = window.getComputedStyle(parent);
                    if (parentStyle.display === 'none' || parentStyle.visibility === 'hidden') {
                        hiddenParent = parent;
                        break;
                    }
                    parent = parent.parentElement;
                }
                if (hiddenParent) {
                    debugLog('âš ï¸ æŒ‰é’®çš„çˆ¶å…ƒç´ è¢«éšè—', {
                        tagName: hiddenParent.tagName,
                        id: hiddenParent.id || 'æ— ',
                        className: hiddenParent.className || 'æ— '
                    });
                }
            } catch (e) {}

            try {
                button.scrollIntoView({ behavior: 'smooth', block: 'center' });
                debugLog('âœ… å·²æ»šåŠ¨åˆ°æŒ‰é’®ä½ç½®');
            } catch (e) {
                debugLog('âŒ æ»šåŠ¨åˆ°æŒ‰é’®ä½ç½®å¤±è´¥', e.message);
            }

            await interruptibleSleep(150);  // ä»300msä¼˜åŒ–åˆ°150ms
            if (!isRunning) return false;

            // å°è¯•å¤šç§ç‚¹å‡»æ–¹å¼
            let clickResults = [];
            
            // ========== å…³é”®æ­¥éª¤ï¼šå…ˆæ¨¡æ‹Ÿé¼ æ ‡ç§»åŠ¨åˆ°æŒ‰é’®ä¸Š ==========
            // è¿™ä¼šè§¦å‘æŒ‰é’®çš„ mouseover/mouseenter äº‹ä»¶ï¼Œåˆå§‹åŒ–å¿…è¦çš„çŠ¶æ€
            debugLog('ğŸ–±ï¸ æ¨¡æ‹Ÿé¼ æ ‡ç§»åŠ¨åˆ°æŒ‰é’®ä¸Š...');
            try {
                const rect = button.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                // è§¦å‘ mouseover äº‹ä»¶
                const mouseOverEvent = new MouseEvent('mouseover', {
                    bubbles: true,
                    cancelable: true,
                    view: window,
                    clientX: centerX,
                    clientY: centerY
                });
                button.dispatchEvent(mouseOverEvent);
                
                // è§¦å‘ mouseenter äº‹ä»¶
                const mouseEnterEvent = new MouseEvent('mouseenter', {
                    bubbles: false,
                    cancelable: false,
                    view: window,
                    clientX: centerX,
                    clientY: centerY
                });
                button.dispatchEvent(mouseEnterEvent);
                
                // è§¦å‘ mousemove äº‹ä»¶
                const mouseMoveEvent = new MouseEvent('mousemove', {
                    bubbles: true,
                    cancelable: true,
                    view: window,
                    clientX: centerX,
                    clientY: centerY
                });
                button.dispatchEvent(mouseMoveEvent);
                
                debugLog('âœ… é¼ æ ‡æ‚¬åœäº‹ä»¶å·²è§¦å‘');
                clickResults.push('é¼ æ ‡æ‚¬åœäº‹ä»¶: å·²è§¦å‘');
            } catch (e) {
                debugLog('âŒ é¼ æ ‡æ‚¬åœäº‹ä»¶è§¦å‘å¤±è´¥', e.message);
            }
            
            // ç­‰å¾…ä¸€æ®µæ—¶é—´ï¼Œè®©æ‚¬åœäº‹ä»¶çš„å¤„ç†é€»è¾‘æ‰§è¡Œ - å·²ä¼˜åŒ–
            await sleep(200);
            
            // ========== é¦–é€‰æ–¹å¼ï¼šç›´æ¥è°ƒç”¨ button.click() ==========
            debugLog('ğŸ–±ï¸ é¦–é€‰æ–¹å¼ï¼šç›´æ¥è°ƒç”¨ button.click()...');
            try {
                button.click();
                clickResults.push('æ–¹å¼0-button.click(): å·²æ‰§è¡Œ');
                debugLog('âœ… button.click() å·²æ‰§è¡Œ');
            } catch (e) {
                clickResults.push(`æ–¹å¼0-button.click(): å¤±è´¥ - ${e.message}`);
                debugLog('âŒ button.click() å¤±è´¥', e.message);
            }
            
            await sleep(200);  // ä»500msä¼˜åŒ–åˆ°200ms
            
            // ========== å¤‡é€‰æ–¹å¼ï¼šä½¿ç”¨ jQuery è§¦å‘ç‚¹å‡» ==========
            debugLog('ğŸ–±ï¸ å¤‡é€‰ï¼šä½¿ç”¨ jQuery è§¦å‘ç‚¹å‡»...');
            
            try {
                if (typeof jQuery !== 'undefined') {
                    const $btn = jQuery(button);
                    if ($btn.length > 0) {
                        $btn.trigger('click');
                        clickResults.push('æ–¹å¼1-jQuery.trigger(click): å·²æ‰§è¡Œ');
                        debugLog('âœ… jQuery ç‚¹å‡»å·²è§¦å‘');
                    }
                }
            } catch (e) {
                clickResults.push(`æ–¹å¼1-jQuery: å¤±è´¥ - ${e.message}`);
            }
            
            await sleep(200);  // ä»500msä¼˜åŒ–åˆ°200ms
            
            // ========== å¤‡é€‰æ–¹å¼ï¼šç›´æ¥è°ƒç”¨ä¿å­˜å‡½æ•° ==========
            debugLog('ï¿½  å°è¯•ç›´æ¥è°ƒç”¨é¡µé¢ä¿å­˜å‡½æ•°...');
            
            // æ–¹å¼0: å°è¯•ç›´æ¥è°ƒç”¨é¡µé¢çš„ä¿å­˜å‡½æ•°ï¼ˆç»•è¿‡äº‹ä»¶æ£€æµ‹ï¼‰
            let directCallSuccess = false;
            try {
                // å°è¯•æŸ¥æ‰¾å¹¶è°ƒç”¨é¡µé¢ä¸Šçš„ä¿å­˜å‡½æ•°
                // å¸¸è§çš„ä¿å­˜å‡½æ•°åç§°
                const saveFunctionNames = ['bc', 'save', 'doSave', 'submitSave', 'xspj_bc', 'btn_xspj_bc_click'];
                
                for (const funcName of saveFunctionNames) {
                    if (typeof window[funcName] === 'function') {
                        debugLog(`âœ… æ‰¾åˆ°é¡µé¢å‡½æ•°: window.${funcName}`);
                        window[funcName]();
                        clickResults.push(`æ–¹å¼0-window.${funcName}(): æˆåŠŸè°ƒç”¨`);
                        directCallSuccess = true;
                        break;
                    }
                }
                
                // å°è¯•ä» jQuery äº‹ä»¶ä¸­æå–å¤„ç†å‡½æ•°å¹¶ç›´æ¥è°ƒç”¨
                if (!directCallSuccess && typeof jQuery !== 'undefined') {
                    const $btn = jQuery(button);
                    
                    // å°è¯•è·å–ç»‘å®šçš„äº‹ä»¶å¤„ç†å‡½æ•°
                    const events = jQuery._data(button, 'events');
                    if (events && events.click && events.click.length > 0) {
                        debugLog('ğŸ” æ‰¾åˆ° jQuery ç»‘å®šçš„ click äº‹ä»¶', { count: events.click.length });
                        
                        // ç›´æ¥è°ƒç”¨äº‹ä»¶å¤„ç†å‡½æ•°ï¼Œä¸é€šè¿‡äº‹ä»¶è§¦å‘
                        for (const handler of events.click) {
                            if (handler.handler && typeof handler.handler === 'function') {
                                debugLog('ğŸ”§ ç›´æ¥è°ƒç”¨äº‹ä»¶å¤„ç†å‡½æ•°...');
                                // åˆ›å»ºä¸€ä¸ªå‡çš„äº‹ä»¶å¯¹è±¡ï¼Œä½†è®¾ç½® isTrusted ç›¸å…³å±æ€§
                                const fakeEvent = {
                                    type: 'click',
                                    target: button,
                                    currentTarget: button,
                                    preventDefault: function() {},
                                    stopPropagation: function() {},
                                    stopImmediatePropagation: function() {}
                                };
                                handler.handler.call(button, fakeEvent);
                                clickResults.push('æ–¹å¼0-ç›´æ¥è°ƒç”¨jQueryäº‹ä»¶å¤„ç†å‡½æ•°: å·²æ‰§è¡Œ');
                                directCallSuccess = true;
                                break;
                            }
                        }
                    }
                }
            } catch (e) {
                clickResults.push(`æ–¹å¼0-ç›´æ¥è°ƒç”¨: å¤±è´¥ - ${e.message}`);
                debugLog('âŒ ç›´æ¥è°ƒç”¨å¤±è´¥', e.message);
            }
            
            // ç­‰å¾…ä¸€ä¸‹çœ‹æ˜¯å¦è§¦å‘äº†ä¿å­˜ - å·²ä¼˜åŒ–
            if (directCallSuccess) {
                await sleep(200);
            }
            
            // ========== æ–¹å¼1ï¼šæ¨¡æ‹Ÿå®Œæ•´é¼ æ ‡äº‹ä»¶åºåˆ— ==========
            if (!directCallSuccess) {
                debugLog('ğŸ–±ï¸ å°è¯•æ¨¡æ‹ŸçœŸå®é¼ æ ‡ç‚¹å‡»...');
                try {
                    const rect = button.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    // å®Œæ•´çš„é¼ æ ‡äº‹ä»¶åºåˆ—
                    const eventSequence = [
                        { type: 'mouseover', bubbles: true },
                        { type: 'mouseenter', bubbles: false },
                        { type: 'mousemove', bubbles: true },
                        { type: 'mousedown', bubbles: true, button: 0, buttons: 1 },
                        { type: 'mouseup', bubbles: true, button: 0, buttons: 0 },
                        { type: 'click', bubbles: true, button: 0, detail: 1 }
                    ];
                    
                    for (const eventConfig of eventSequence) {
                        const event = new MouseEvent(eventConfig.type, {
                            bubbles: eventConfig.bubbles,
                            cancelable: true,
                            view: window,
                            clientX: centerX,
                            clientY: centerY,
                            button: eventConfig.button || 0,
                            buttons: eventConfig.buttons || 0,
                            detail: eventConfig.detail || 0
                        });
                        button.dispatchEvent(event);
                        await sleep(30);  // æ¯ä¸ªäº‹ä»¶ä¹‹é—´ç¨å¾®ç­‰å¾…
                    }
                    
                    clickResults.push('æ–¹å¼1-æ¨¡æ‹Ÿé¼ æ ‡äº‹ä»¶åºåˆ—: å·²æ‰§è¡Œ');
                    debugLog('âœ… æ¨¡æ‹ŸçœŸå®é¼ æ ‡ç‚¹å‡»å®Œæˆ');
                    
                } catch (e) {
                    clickResults.push(`æ–¹å¼1-æ¨¡æ‹Ÿé¼ æ ‡: å¤±è´¥ - ${e.message}`);
                }
            }
            
            await sleep(150);  // ä»300msä¼˜åŒ–åˆ°150ms
            
            // ========== æ–¹å¼2ï¼šä½¿ç”¨ jQuery è§¦å‘ ==========
            try {
                if (typeof jQuery !== 'undefined') {
                    const $btn = jQuery(button);
                    debugLog('ğŸ” jQuery é€‰æ‹©å™¨ç»“æœ', { 
                        length: $btn.length,
                        is_visible: $btn.is(':visible')
                    });
                    
                    if ($btn.length > 0) {
                        $btn.trigger('click');
                        clickResults.push('æ–¹å¼2-jQuery.trigger(click): å·²æ‰§è¡Œ');
                    }
                }
            } catch (e) {
                clickResults.push(`æ–¹å¼2-jQuery: å¤±è´¥ - ${e.message}`);
            }
            
            // ========== æ–¹å¼3ï¼šå°è¯•æäº¤è¡¨å• ==========
            try {
                const form = button.closest('form');
                if (form) {
                    debugLog('ğŸ” æ‰¾åˆ°è¡¨å•', { id: form.id, action: form.action });
                    // ä¸ç›´æ¥æäº¤ï¼Œåªæ˜¯è®°å½•
                    clickResults.push(`æ–¹å¼3-æ‰¾åˆ°è¡¨å•: ${form.id || 'æ— ID'}`);
                }
            } catch (e) {}

            debugLog('ğŸ“‹ ç‚¹å‡»å°è¯•ç»“æœæ±‡æ€»', clickResults);
            return true;
        }
        
        // ç­‰å¾…å¼¹çª—å‡ºç°å¹¶å¤„ç† - å·²ä¼˜åŒ–
        async waitAndHandleDialog(maxWaitMs) {
            const startTime = Date.now();
            const checkInterval = 200;  // ä»300msä¼˜åŒ–åˆ°200ms
            
            debugLog(`â³ waitAndHandleDialog: å¼€å§‹ç­‰å¾…å¼¹çª—ï¼ˆæœ€å¤š ${maxWaitMs}msï¼‰`);
            
            while (Date.now() - startTime < maxWaitMs) {
                if (!isRunning) return { handled: false, type: 'stopped' };
                
                // æ£€æŸ¥æ˜¯å¦æœ‰å¯è§çš„å¼¹çª—
                const dialogInfo = this.findVisibleDialog();
                if (dialogInfo.found) {
                    debugLog('âœ… å‘ç°å¼¹çª—', { type: dialogInfo.type, text: dialogInfo.text.substring(0, 50) });
                    
                    // ç­‰å¾…å¼¹çª—å®Œå…¨æ¸²æŸ“ - å·²ä¼˜åŒ–
                    await sleep(100);
                    
                    // ç‚¹å‡»ç¡®è®¤æŒ‰é’®
                    if (tryClickConfirmInDialog(dialogInfo.dialog)) {
                        debugLog('âœ… å·²ç‚¹å‡»å¼¹çª—ç¡®è®¤æŒ‰é’®', { type: dialogInfo.type });
                        await interruptibleSleep(300);  // ä»500msä¼˜åŒ–åˆ°300ms
                        return { handled: true, type: dialogInfo.type };
                    }
                }
                
                await sleep(checkInterval);
            }
            
            debugLog(`âš ï¸ waitAndHandleDialog: ç­‰å¾…è¶…æ—¶ï¼ˆ${maxWaitMs}msï¼‰`);
            return { handled: false, type: 'timeout' };
        }
        
        // æŸ¥æ‰¾å¯è§çš„å¼¹çª—
        findVisibleDialog() {
            const dialogSelectors = [
                '#successModal',  // æˆåŠŸå¼¹çª—ä¼˜å…ˆ
                '#alertModal',
                '.bootbox.modal.in',
                '.bootbox.modal',
                '.bootbox',
                '.modal.in',
                '[role="dialog"]'
            ];
            
            for (const selector of dialogSelectors) {
                try {
                    const dialogs = document.querySelectorAll(selector);
                    for (let i = 0; i < dialogs.length; i++) {
                        const dialog = dialogs[i];
                        if (!dialog) continue;
                        
                        // æ£€æŸ¥å¼¹çª—æ˜¯å¦å¯è§ï¼ˆåŒ…æ‹¬ display: blockï¼‰
                        const style = window.getComputedStyle ? window.getComputedStyle(dialog) : null;
                        const isVisible = style && style.display !== 'none' && style.visibility !== 'hidden';
                        if (!isVisible) continue;
                        
                        const text = getElementTextSafe(dialog);
                        if (!text) continue;
                        
                        // åˆ¤æ–­å¼¹çª—ç±»å‹
                        let type = 'unknown';
                        if (isInjectionWarningText(text)) {
                            type = 'injection_warning';
                        } else if (text.indexOf('æˆåŠŸ') >= 0 || text.indexOf('å®Œæˆ') >= 0 || 
                                   text.indexOf('å·²è¯„') >= 0 || text.indexOf('ä¿å­˜') >= 0) {
                            type = 'success';
                        }
                        
                        return { found: true, dialog, type, text };
                    }
                } catch (e) {}
            }
            
            return { found: false };
        }
        
        // æ–¹æ¡ˆä¸€ï¼šç›‘å¬å¼¹çª—æ¶ˆå¤±ï¼Œè€Œéå›ºå®šç­‰å¾…
        async waitForDialogClose(dialogElement) {
            const maxWait = 500;  // æœ€å¤šç­‰å¾…500ms
            const checkInterval = 20;  // æ¯20msæ£€æµ‹ä¸€æ¬¡
            let waited = 0;
            
            while (waited < maxWait) {
                // æ£€æŸ¥å¼¹çª—æ˜¯å¦å·²ä»DOMç§»é™¤æˆ–éšè—
                if (!dialogElement || !document.contains(dialogElement)) {
                    debugLog('å¼¹çª—å·²ä»DOMç§»é™¤');
                    return true;
                }
                
                const style = window.getComputedStyle ? window.getComputedStyle(dialogElement) : null;
                if (style && (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0')) {
                    debugLog('å¼¹çª—å·²éšè—');
                    return true;
                }
                
                await sleep(checkInterval);
                waited += checkInterval;
            }
            
            debugLog('å¼¹çª—å…³é—­ç­‰å¾…è¶…æ—¶');
            return false;
        }
        
        // éªŒè¯ä¿å­˜æ˜¯å¦æˆåŠŸ - å·²ä¼˜åŒ–
        async verifySaveSuccess(courseInfo, beforeStatus) {
            // æ£€æŸ¥å¤šæ¬¡ï¼Œå› ä¸ºçŠ¶æ€æ›´æ–°å¯èƒ½æœ‰å»¶è¿Ÿ
            for (let i = 0; i < 8; i++) {  // ä»10æ¬¡ä¼˜åŒ–åˆ°8æ¬¡
                if (!isRunning) return false;
                
                const currentRow = this.getSelectedCourseRow() || this.findCourseRowByName(courseInfo && courseInfo.courseName);
                const status = this.getRowStatusText(currentRow);
                
                if (status && this.isSavedStatusText(status)) {
                    if (!beforeStatus || status !== beforeStatus) {
                        debugLog('éªŒè¯ä¿å­˜æˆåŠŸ', { beforeStatus, status });
                        return true;
                    }
                }
                
                await interruptibleSleep(200);  // ä»300msä¼˜åŒ–åˆ°200ms
            }
            
            debugLog('éªŒè¯ä¿å­˜å¤±è´¥ï¼ŒçŠ¶æ€æœªå˜æ›´');
            return false;
        }

        isSaveButton(element) {
            const text = (element.textContent || element.value || '').trim();
            if (!text) return false;
            if (text.indexOf('ä¿å­˜') < 0) return false;
            if (text.indexOf('æäº¤') >= 0) return false;
            return true;
        }
    }

    class CourseSwitcher {
        async switchToCourse(courseInfo) {
            try {
                if (!courseInfo || !courseInfo.element) return false;
                debugLog(`å‡†å¤‡åˆ‡æ¢åˆ°è¯¾ç¨‹: ${courseInfo.courseName}`);

                if (!isRunning) return false;
                
                // åˆ‡æ¢å‰å…ˆå…³é—­æ‰€æœ‰å¯èƒ½å­˜åœ¨çš„å¼¹çª—
                await this.closeAllDialogs();
                
                const beforeCourseText = this.getCurrentCourseDisplayText();

                // è·å–è¡ŒIDï¼ˆjqGridä½¿ç”¨è¡Œçš„idå±æ€§ï¼‰
                const rowId = courseInfo.element.id;
                if (!rowId) {
                    debugLog('æœªæ‰¾åˆ°è¡ŒID');
                    return false;
                }

                debugLog(`ä½¿ç”¨ jqGrid API é€‰æ‹©è¡Œ: ${rowId}`);

                // æ»šåŠ¨åˆ°è¯¾ç¨‹è¡Œ
                try {
                    courseInfo.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                } catch (e) {}

                await sleep(150);  // ä»300msä¼˜åŒ–åˆ°150ms
                if (!isRunning) return false;
                
                // å†æ¬¡æ£€æŸ¥å¹¶å…³é—­å¼¹çª—
                await this.closeAllDialogs();

                // ä½¿ç”¨ jqGrid API é€‰æ‹©è¡Œ
                let selectSuccess = false;
                try {
                    if (typeof jQuery !== 'undefined' && jQuery('#tempGrid').jqGrid) {
                        // ä½¿ç”¨ jqGrid çš„ setSelection æ–¹æ³•é€‰ä¸­è¡Œ
                        jQuery('#tempGrid').jqGrid('setSelection', rowId, true);
                        selectSuccess = true;
                        debugLog(`jqGrid setSelection æˆåŠŸ: ${rowId}`);
                    }
                } catch (e) {
                    debugLog('jqGrid setSelection å¤±è´¥', e);
                }

                // å¦‚æœ jqGrid API å¤±è´¥ï¼Œä½¿ç”¨ jQuery è§¦å‘ç‚¹å‡»
                if (!selectSuccess) {
                    try {
                        if (typeof jQuery !== 'undefined') {
                            jQuery(courseInfo.element).trigger('click');
                            selectSuccess = true;
                            debugLog('ä½¿ç”¨ jQuery trigger click');
                        }
                    } catch (e) {
                        debugLog('jQuery trigger click å¤±è´¥', e);
                    }
                }

                // æœ€åå¤‡ç”¨ï¼šåŸç”Ÿç‚¹å‡»
                if (!selectSuccess) {
                    try {
                        courseInfo.element.click();
                        debugLog('ä½¿ç”¨åŸç”Ÿ click');
                    } catch (e) {}
                }

                debugLog(`å·²é€‰æ‹©è¯¾ç¨‹: ${courseInfo.courseName}`);

                await this.waitForPageLoad();
                const success = await this.verifySwitch(courseInfo, beforeCourseText);

                if (success) {
                    debugLog(`æˆåŠŸåˆ‡æ¢åˆ°è¯¾ç¨‹: ${courseInfo.courseName}`);
                } else {
                    debugLog(`è¯¾ç¨‹åˆ‡æ¢éªŒè¯å¤±è´¥: ${courseInfo.courseName}`);
                }

                return success;

            } catch (error) {
                debugLog(`åˆ‡æ¢è¯¾ç¨‹å¤±è´¥: ${courseInfo && courseInfo.courseName ? courseInfo.courseName : ''}`, error);
                return false;
            }
        }

        async waitForPageLoad() {
            const maxWaitTime = config.pageLoadTimeout || 8000;
            const checkInterval = config.elementCheckInterval || 300;
            let waitTime = 0;

            while (waitTime < maxWaitTime) {
                if (!isRunning) return false;

                const ok = await this.checkPageLoadStatus();
                if (ok) {
                    debugLog('é¡µé¢åŠ è½½å®Œæˆ');
                    return true;
                }

                await sleep(checkInterval);
                waitTime += checkInterval;
            }

            debugLog('é¡µé¢åŠ è½½è¶…æ—¶');
            return false;
        }

        async checkPageLoadStatus() {
            try {
                // å…ˆæ£€æŸ¥å¹¶å…³é—­å¯èƒ½å­˜åœ¨çš„å¼¹çª—
                try {
                    findAndConfirmInjectionWarningOnce();
                } catch (e) {}
                
                const form = document.querySelector('#ajaxForm1') || document.querySelector('form#ajaxForm1');
                const table = document.querySelector('table.table-xspj');
                const anyRadio = document.querySelector('input[type="radio"]');

                if (anyRadio) return true;
                if (form && form.querySelector && form.querySelector('input[type="radio"]')) return true;
                if (table && table.querySelector && table.querySelector('input[type="radio"]')) return true;

                const loadingIndicators = document.querySelectorAll('.loading, .spinner, [class*="loading"], .ui-widget-overlay.jqgrid-overlay');
                const hasLoading = safeSome(loadingIndicators, (indicator) => {
                    if (!indicator) return false;
                    try {
                        if (!isLikelyVisible(indicator)) return false;
                    } catch (e) {}
                    return true;
                });
                if (hasLoading) return false;

                return !!(form || table);
            } catch (e) {
                return true;
            }
        }
        
        // å…³é—­æ‰€æœ‰å¯èƒ½å­˜åœ¨çš„å¼¹çª—
        async closeAllDialogs() {
            const maxAttempts = 5;
            for (let i = 0; i < maxAttempts; i++) {
                try {
                    // å°è¯•å…³é—­ä»»ä½•å¯è§çš„å¼¹çª—
                    const dialogs = document.querySelectorAll('#alertModal, #successModal, .bootbox.modal, .bootbox, .modal, [role="dialog"]');
                    let closedAny = false;
                    
                    for (let j = 0; j < dialogs.length; j++) {
                        const dialog = dialogs[j];
                        if (!dialog) continue;
                        if (!isLikelyVisible(dialog)) continue;
                        
                        // å°è¯•ç‚¹å‡»ç¡®å®šæŒ‰é’®
                        if (tryClickConfirmInDialog(dialog)) {
                            debugLog('closeAllDialogs: å…³é—­äº†ä¸€ä¸ªå¼¹çª—');
                            closedAny = true;
                            await sleep(300);
                            break;  // å…³é—­ä¸€ä¸ªåé‡æ–°æ£€æµ‹
                        }
                    }
                    
                    if (!closedAny) {
                        // æ²¡æœ‰æ›´å¤šå¼¹çª—éœ€è¦å…³é—­
                        break;
                    }
                } catch (e) {}
            }
        }

        async verifySwitch(courseInfo, beforeCourseText = '') {
            try {
                const maxWaitTime = config.pageLoadTimeout || 10000;
                const checkInterval = 300;
                let waitTime = 0;

                while (waitTime < maxWaitTime) {
                    if (!isRunning) return false;

                    const rowSelected = this.isCourseRowSelected(courseInfo && courseInfo.element);
                    const currentCourseText = this.getCurrentCourseDisplayText();
                    const textMatch = this.isCourseTextMatch(courseInfo, currentCourseText, beforeCourseText);
                    const hasScoreElements = this.hasEvaluationScoreElements();

                    if (textMatch) return true;
                    if (rowSelected && hasScoreElements) return true;
                    if (rowSelected && currentCourseText && currentCourseText !== beforeCourseText) return true;

                    await sleep(checkInterval);
                    waitTime += checkInterval;
                }

                return false;
            } catch (error) {
                debugLog('éªŒè¯è¯¾ç¨‹åˆ‡æ¢æ—¶å‡ºé”™', error);
                return false;
            }
        }

        isCourseRowSelected(row) {
            if (!row) return false;
            try {
                const ariaSelected = row.getAttribute && row.getAttribute('aria-selected');
                if (ariaSelected === 'true') return true;
                if (row.classList && row.classList.contains('ui-state-highlight')) return true;
                if (row.className && row.className.indexOf('ui-state-highlight') >= 0) return true;
            } catch (e) {
                return false;
            }
            return false;
        }

        hasEvaluationScoreElements() {
            const anyRadio = document.querySelector('input[type="radio"]');
            if (anyRadio) return true;

            const scope = document.querySelector('#ajaxForm1') || document;
            try {
                if (scope.querySelector && scope.querySelector('input[type="radio"]')) return true;
            } catch (e) {}

            const table = document.querySelector('table.table-xspj');
            if (table) {
                try {
                    if (table.querySelector('input[type="radio"]')) return true;
                } catch (e) {}
            }
            return false;
        }

        getCurrentCourseDisplayText() {
            const selectors = ['#ajaxForm1 .col-sm-8', '#ajaxForm1', '.col-sm-8', '#yhgnPage'];
            for (let i = 0; i < selectors.length; i++) {
                let nodes = [];
                try {
                    nodes = document.querySelectorAll(selectors[i]);
                } catch (e) {
                    nodes = [];
                }
                const len = typeof nodes.length === 'number' ? nodes.length : 0;
                for (let j = 0; j < len; j++) {
                    const el = nodes[j];
                    const text = el && el.textContent ? el.textContent.trim() : '';
                    if (text && text.indexOf('å½“å‰è¯„ä»·è¯¾ç¨‹ä¸º') >= 0) return text;
                }
            }
            return '';
        }

        isCourseTextMatch(courseInfo, currentText, beforeText) {
            const expected = courseInfo && courseInfo.courseName ? String(courseInfo.courseName) : '';
            if (!expected) return false;
            if (!currentText) return false;
            if (beforeText && currentText === beforeText) return false;
            return currentText.indexOf(expected) >= 0;
        }
    }

    class EvaluationController {
        constructor() {
            this.courseManager = new CourseManager();
            this.scoringManager = new ScoringManager();
            this.commentGenerator = new CommentGenerator();
            this.saveManager = new SaveManager();
            this.courseSwitcher = new CourseSwitcher();
        }

        async startEvaluation() {
            if (isRunning) {
                debugLog("è¯„ä»·æ­£åœ¨è¿›è¡Œä¸­");
                return;
            }

            isRunning = true;
            isPaused = false;
            processedCourses = 0;
            evaluationResults = [];

            try {
                updateStatus("æ­£åœ¨è·å–è¯¾ç¨‹åˆ—è¡¨...");

                const courses = await this.courseManager.getUnevaluatedCourses();

                if (courses.length === 0) {
                    updateStatus("æ²¡æœ‰éœ€è¦è¯„ä»·çš„è¯¾ç¨‹");
                    return;
                }

                totalCourses = courses.length;
                updateStatus(`æ‰¾åˆ° ${totalCourses} é—¨éœ€è¦è¯„ä»·çš„è¯¾ç¨‹`);

                for (let i = 0; i < courses.length; i++) {
                    if (!isRunning) {
                        updateStatus("å·²åœæ­¢");
                        break;
                    }
                    await checkPause();

                    if (!isRunning) {
                        updateStatus("å·²åœæ­¢");
                        break;
                    }

                    const course = courses[i];
                    processedCourses = i + 1;

                    updateProgress(processedCourses, totalCourses);
                    updateStatus(`æ­£åœ¨è¯„ä»·ç¬¬ ${processedCourses}/${totalCourses} é—¨è¯¾ç¨‹: ${course.courseName}`);

                    const result = await this.evaluateSingleCourse(course);
                    evaluationResults.push(result);

                    if (!isRunning) {
                        updateStatus("å·²åœæ­¢");
                        break;
                    }

                    await interruptibleSleep(config.delayBetweenCourses);
                }

                if (isRunning) {
                    // æ‰€æœ‰è¯¾ç¨‹è¯„ä»·å®Œæˆ
                    updateStatus("æ‰€æœ‰è¯¾ç¨‹è¯„ä»·å®Œæˆï¼Œè¯·æ‰‹åŠ¨ç‚¹å‡»æäº¤æŒ‰é’®");
                    showResults();
                }

            } catch (error) {
                debugLog("è¯„ä»·è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯", error);
                updateStatus("è¯„ä»·å‡ºç°é”™è¯¯ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°");
            } finally {
                isRunning = false;
            }
        }

        async evaluateSingleCourse(course) {
            const result = {
                course: course,
                success: false,
                error: null,
                timestamp: new Date()
            };

            try {
                if (!isRunning) {
                    result.error = 'å·²åœæ­¢';
                    return result;
                }

                const switchSuccess = await this.courseSwitcher.switchToCourse(course);
                if (!switchSuccess) {
                    throw new Error('è¯¾ç¨‹åˆ‡æ¢å¤±è´¥');
                }

                await interruptibleSleep(config.delayBetweenActions);
                if (!isRunning) throw new Error('å·²åœæ­¢');

                const scoreSuccess = await this.scoringManager.fillScores();
                if (!scoreSuccess) {
                    debugLog("æœªæ‰¾åˆ°è¯„åˆ†å…ƒç´ ï¼Œå¯èƒ½å·²ç»è¯„ä»·è¿‡");
                }

                await interruptibleSleep(config.delayBetweenActions);
                if (!isRunning) throw new Error('å·²åœæ­¢');

                const commentSuccess = await this.commentGenerator.fillComments();
                if (!commentSuccess) {
                    debugLog("æœªæ‰¾åˆ°è¯„è¯­æ–‡æœ¬æ¡†");
                }

                await interruptibleSleep(config.delayBetweenActions * 2);
                if (!isRunning) throw new Error('å·²åœæ­¢');

                const saveSuccess = await this.saveManager.saveEvaluation(course);
                if (!saveSuccess) {
                    throw new Error('ä¿å­˜å¤±è´¥');
                }

                result.success = true;
                debugLog(`è¯¾ç¨‹è¯„ä»·å®Œæˆ: ${course.courseName}`);

            } catch (error) {
                result.error = error.message;
                debugLog(`è¯¾ç¨‹è¯„ä»·å¤±è´¥: ${course.courseName}`, error);
            }

            
            return result;
        }
        
        // æš‚åœè¯„ä»·
        pauseEvaluation() {
            isPaused = true;
            updateStatus("å·²æš‚åœ");
        }
        
        // ç»§ç»­è¯„ä»·
        resumeEvaluation() {
            isPaused = false;
            updateStatus("è¯„ä»·è¿›è¡Œä¸­...");
        }
        
        // åœæ­¢è¯„ä»·
        stopEvaluation() {
            isRunning = false;
            isPaused = false;
            updateStatus("å·²åœæ­¢");
        }
    }
    
    // ==================== UI ç•Œé¢æ¨¡å— ====================
    
    // åˆ›å»ºæ§åˆ¶é¢æ¿
    function createControlPanel() {
        // 1. æ³¨å…¥CSSæ ·å¼
        const style = document.createElement('style');
        style.textContent = `
        /* CSSå˜é‡ */
        :root {
            --ae-primary: #667eea;
            --ae-accent: #764ba2;
            --ae-success: #48bb78;
            --ae-warning: #ed8936;
            --ae-danger: #f56565;
            --ae-white: rgba(255, 255, 255, 0.95);
            --ae-text: #2d3748;
            --ae-text-light: #718096;
        }

        /* å®¹å™¨ */
        #ae-widget-container {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 10000;
            font-family: "Microsoft YaHei", "Segoe UI", sans-serif;
            display: flex;
            flex-direction: column-reverse;
            align-items: flex-end;
            gap: 15px;
        }

        /* æœºå™¨äººæ‚¬æµ®çƒ */
        #ae-floating-ball {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, var(--ae-primary) 0%, var(--ae-accent) 100%);
            border-radius: 50%;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 32px;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            user-select: none;
            animation: ae-float 3s ease-in-out infinite;
            position: relative;
            z-index: 10001;
        }
        
        #ae-floating-ball:hover {
            transform: scale(1.1) rotate(10deg);
            box-shadow: 0 6px 20px rgba(0,0,0,0.25);
        }
        
        #ae-floating-ball:active {
            transform: scale(0.95);
        }

        /* çŠ¶æ€å°çº¢ç‚¹ */
        .ae-status-dot {
            position: absolute;
            top: 0;
            right: 0;
            width: 14px;
            height: 14px;
            background-color: #4CAF50;
            border: 2px solid white;
            border-radius: 50%;
            display: none; /* é»˜è®¤éšè— */
        }

        /* ä¸»é¢æ¿ */
        #auto-eval-panel {
            width: 300px;
            background: var(--ae-white);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: var(--ae-shadow);
            padding: 20px;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            opacity: 0;
            transform: scale(0.8) translateY(20px);
            transform-origin: bottom right;
            pointer-events: none; /* éšè—æ—¶ä¸å“åº”ç‚¹å‡» */
            visibility: hidden;
        }

        /* é¢æ¿å±•å¼€çŠ¶æ€ */
        #auto-eval-panel.visible {
            opacity: 1;
            transform: scale(1) translateY(0);
            pointer-events: all;
            visibility: visible;
        }

        /* æ ‡é¢˜åŒºåŸŸ */
        .ae-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 2px dashed #eee;
            padding-bottom: 10px;
        }

        .ae-title {
            font-size: 16px;
            font-weight: bold;
            color: var(--ae-accent);
            margin-left: 10px;
            flex-grow: 1;
        }
        
        .ae-version {
            font-size: 10px;
            color: #999;
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 10px;
        }

        /* æ§åˆ¶æŒ‰é’®ç»„ */
        .ae-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .ae-btn {
            border: none;
            border-radius: 12px;
            padding: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.2s;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        #start-btn { background: linear-gradient(45deg, #28a745 0%, #20c997 100%); color: #333; }
        #pause-btn { background: linear-gradient(45deg, #ffc107 0%, #ffca2c 100%); color: #333; }
        #stop-btn  { background: linear-gradient(45deg, #f77062 0%, #fe5196 100%); color: #333; }

        .ae-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
        .ae-btn:active { transform: translateY(0); }

        /* è¿›åº¦æ¡ */
        .ae-progress-container {
            background: #f0f2f5;
            border-radius: 10px;
            height: 18px;
            overflow: hidden;
            margin-bottom: 8px;
            border: 1px solid rgba(0,0,0,0.05);
        }

        #progress-bar {
            background: linear-gradient(90deg, var(--ae-accent), var(--ae-primary));
            height: 100%;
            width: 0%;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        /* çŠ¶æ€æ–‡æœ¬ */
        #status {
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 12px;
            font-size: 12px;
            color: var(--ae-text);
            text-align: center;
            border: 1px dashed var(--ae-primary);
            min-height: 20px;
        }

        /* æµ®åŠ¨åŠ¨ç”» */
        @keyframes ae-float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }
    `;
    document.head.appendChild(style);

    // 2. åˆ›å»º DOM ç»“æ„
    const container = document.createElement('div');
    container.id = 'ae-widget-container';
    
    container.innerHTML = `
        <!-- ä¸»é¢æ¿ -->
        <div id="auto-eval-panel">
            <div class="ae-header">
                <span style="font-size: 24px;">ğŸ¤–</span>
                <div class="ae-title">è¯„ä»·å°åŠ©æ‰‹</div>
                <span class="ae-version">v1.0</span>
            </div>
            
            <div class="ae-controls">
                <button id="start-btn" class="ae-btn" title="å¼€å§‹è¯„ä»·">
                    <span>â–¶</span> å¼€å§‹
                </button>
                <button id="pause-btn" class="ae-btn" title="æš‚åœ/ç»§ç»­">
                    <span>â¸</span> æš‚åœ
                </button>
                <button id="stop-btn" class="ae-btn" title="åœæ­¢">
                    <span>â¹</span> åœæ­¢
                </button>
            </div>

            <div class="ae-progress-container">
                <div id="progress-bar">0%</div>
            </div>
            
            <div id="status">å‡†å¤‡å°±ç»ªï¼Œç‚¹å‡»å¼€å§‹å–µ~</div>
            
            <!-- éšè—çš„æµ‹è¯•æŒ‰é’® -->
            <button id="test-btn" style="display: none;"></button>
        </div>

        <!-- æ‚¬æµ®çƒ -->
        <div id="ae-floating-ball" title="ç‚¹å‡»å±•å¼€/æ”¶èµ·">
            ğŸ¤–
            <div class="ae-status-dot"></div>
        </div>
    `;

    document.body.appendChild(container);

    // 3. ç»‘å®šæ‚¬æµ®çƒäº¤äº’ï¼ˆæ”¯æŒæ‹–åŠ¨ï¼‰
    const ball = document.getElementById('ae-floating-ball');
    const panel = document.getElementById('auto-eval-panel');
    const widgetContainer = document.getElementById('ae-widget-container');
    
    let isDragging = false;
    let dragStartX, dragStartY;
    let startRight, startBottom;
    
    // é¼ æ ‡æŒ‰ä¸‹
    ball.addEventListener('mousedown', (e) => {
        isDragging = false;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        const rect = widgetContainer.getBoundingClientRect();
        startRight = window.innerWidth - rect.right;
        startBottom = window.innerHeight - rect.bottom;
        
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
        e.preventDefault();
    });
    
    function onMouseMove(e) {
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;
        
        // ç§»åŠ¨è¶…è¿‡5pxæ‰ç®—æ‹–åŠ¨
        if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
            isDragging = true;
            const newRight = Math.max(10, startRight - dx);
            const newBottom = Math.max(10, startBottom - dy);
            widgetContainer.style.right = newRight + 'px';
            widgetContainer.style.bottom = newBottom + 'px';
        }
    }
    
    function onMouseUp(e) {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        
        // å¦‚æœä¸æ˜¯æ‹–åŠ¨ï¼Œåˆ™è§¦å‘ç‚¹å‡»
        if (!isDragging) {
            panel.classList.toggle('visible');
        }
    }

    // 4. é»˜è®¤å±•å¼€é¢æ¿
    panel.classList.add('visible');
    
    // 5. ç»‘å®šåŸæœ‰åŠŸèƒ½äº‹ä»¶
    bindEvents();
}

// ç»‘å®šäº‹ä»¶
function bindEvents() {
    const controller = new EvaluationController();
    
    // å¼€å§‹æŒ‰é’®
    const startBtn = document.getElementById('start-btn');
    if (startBtn) {
        startBtn.addEventListener('click', () => {
            updateConfig();
            // ä¿æŒé¢æ¿å±•å¼€
            const panel = document.getElementById('auto-eval-panel');
            if (panel && !panel.classList.contains('visible')) {
                panel.classList.add('visible');
            }
            controller.startEvaluation();
        });
    }
    
    // æš‚åœæŒ‰é’®
    const pauseBtn = document.getElementById('pause-btn');
    if (pauseBtn) {
        pauseBtn.addEventListener('click', () => {
            if (isPaused) {
                controller.resumeEvaluation();
                pauseBtn.innerHTML = '<span>â¸</span> æš‚åœ';
            } else {
                controller.pauseEvaluation();
                pauseBtn.innerHTML = '<span>â–¶</span> ç»§ç»­';
            }
        });
    }
    
    // åœæ­¢æŒ‰é’®
    const stopBtn = document.getElementById('stop-btn');
    if (stopBtn) {
        stopBtn.addEventListener('click', () => {
            controller.stopEvaluation();
            if (pauseBtn) {
                pauseBtn.innerHTML = '<span>â¸</span> æš‚åœ';
            }
        });
    }
    
    // æµ‹è¯•æŒ‰é’®ï¼ˆéšè—ï¼Œä¾›è‡ªåŠ¨æµ‹è¯•ä½¿ç”¨ï¼‰
    const testBtn = document.getElementById('test-btn');
    if (testBtn) {
        testBtn.addEventListener('click', testFunction);
    }
}
    
    // æ›´æ–°é…ç½®ï¼ˆç®€åŒ–ç‰ˆï¼‰
    function updateConfig() {
        // é…ç½®å·²åœ¨ä»£ç ä¸­é¢„è®¾ï¼Œæ— éœ€UIæ›´æ–°
    }
    
    // æ›´æ–°çŠ¶æ€ - å·²ä¿®å¤ï¼šåªæ›´æ–°statuså…ƒç´ ï¼Œé¿å…é‡å¤æ˜¾ç¤º
    function updateStatus(message) {
        const statusElement = document.getElementById('status');
        
        if (statusElement) {
            statusElement.textContent = message;
        }
        
        debugLog("çŠ¶æ€æ›´æ–°", message);
    }
    
    // æ›´æ–°è¿›åº¦
    function updateProgress(current, total) {
        const percentage = Math.round((current / total) * 100);
        const progressBar = document.getElementById('progress-bar');
        
        if (progressBar) {
            progressBar.style.width = percentage + '%';
            progressBar.textContent = percentage + '%';
        }
        
        debugLog(`è¿›åº¦æ›´æ–°`, `${current}/${total} (${percentage}%)`);
    }
    
    // æµ‹è¯•åŠŸèƒ½
    async function testFunction() {
        updateStatus("æµ‹è¯•ä¸­...");
        
        try {
            // è¯¦ç»†é¡µé¢åˆ†æ
            debugLog("=== å¼€å§‹é¡µé¢åˆ†æ ===");
            
            // 1. æ£€æŸ¥æ‰€æœ‰è¡¨æ ¼
            const allTables = document.querySelectorAll('table');
            debugLog(`æ‰¾åˆ° ${allTables.length} ä¸ªè¡¨æ ¼`, allTables);
            
            for (let i = 0; i < allTables.length; i++) {
                const table = allTables[i];
                debugLog(`è¡¨æ ¼ ${i + 1}:`, {
                    className: table.className,
                    id: table.id,
                    rowCount: table.querySelectorAll('tr').length
                });
            }
            
            // 2. æ£€æŸ¥æ‰€æœ‰è¡Œ
            const allRows = document.querySelectorAll('tr');
            debugLog(`æ‰¾åˆ° ${allRows.length} ä¸ªè¡¨æ ¼è¡Œ`);
            
            for (let i = 0; i < allRows.length; i++) {
                if (i < 10) {
                    const row = allRows[i];
                    const cells = row.querySelectorAll('td');
                    debugLog(`è¡Œ ${i + 1}:`, {
                        cellCount: cells.length,
                        text: row.textContent.trim().substring(0, 100),
                        className: row.className
                    });
                }
            }
            
            // 3. æµ‹è¯•è¯¾ç¨‹æŸ¥æ‰¾
            const courseManager = new CourseManager();
            const courses = await courseManager.getAllCourses();
            const unevaluated = await courseManager.getUnevaluatedCourses();
            
            // 4. æµ‹è¯•è¯„åˆ†å…ƒç´ 
            const scoreButtons = document.querySelectorAll('input[type="radio"]');
            const textareas = document.querySelectorAll('textarea');
            const saveButtons = document.querySelectorAll('button, input[type="button"]');
            
            let saveButtonCount = 0;
            for (let i = 0; i < saveButtons.length; i++) {
                const btn = saveButtons[i];
                if (!btn) continue;
                if ((btn.textContent || btn.value || '').includes('ä¿å­˜')) {
                    saveButtonCount++;
                }
            }
            
            // 5. æ£€æŸ¥é¡µé¢ç»“æ„
            const pageStructure = {
                tables: allTables.length,
                rows: allRows.length,
                courses: courses.length,
                unevaluatedCourses: unevaluated.length,
                scoreButtons: scoreButtons.length,
                textareas: textareas.length,
                saveButtons: saveButtonCount,
                pageUrl: window.location.href,
                pageTitle: document.title
            };
            
            updateStatus(`è¡¨æ ¼:${pageStructure.tables} è¡Œ:${pageStructure.rows} è¯¾ç¨‹:${pageStructure.courses} å¾…è¯„:${pageStructure.unevaluatedCourses}`);
            
            debugLog("=== é¡µé¢ç»“æ„åˆ†æç»“æœ ===", pageStructure);
            debugLog("=== è¯¾ç¨‹è¯¦ç»†ä¿¡æ¯ ===", courses);
            
            // 6. å¦‚æœæ²¡æœ‰æ‰¾åˆ°è¯¾ç¨‹ï¼Œæä¾›æ›´å¤šè°ƒè¯•ä¿¡æ¯
            if (courses.length === 0) {
                debugLog("=== æœªæ‰¾åˆ°è¯¾ç¨‹ï¼Œæä¾›æ›´å¤šè°ƒè¯•ä¿¡æ¯ ===");
                
                // æ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„è¯¾ç¨‹ç›¸å…³å…ƒç´ 
                const possibleElements = [
                    ...document.querySelectorAll('[class*="course"]'),
                    ...document.querySelectorAll('[class*="eval"]'),
                    ...document.querySelectorAll('[class*="è¯„ä»·"]'),
                    ...document.querySelectorAll('[id*="course"]'),
                    ...document.querySelectorAll('[id*="eval"]')
                ];
                
                debugLog("å¯èƒ½çš„è¯¾ç¨‹ç›¸å…³å…ƒç´ :", possibleElements);
                
                // æ£€æŸ¥æ‰€æœ‰åŒ…å«å…³é”®è¯çš„å…ƒç´ 
                const keywordElements = [];
                const keywords = ['æœªè¯„', 'å·²è¯„', 'è¯¾ç¨‹', 'æ•™å¸ˆ', 'è¯„ä»·'];
                for (let i = 0; i < keywords.length; i++) {
                    const keyword = keywords[i];
                    const nodes = document.querySelectorAll('*');
                    const elements = [];
                    for (let j = 0; j < nodes.length; j++) {
                        const el = nodes[j];
                        if (el && el.textContent && el.textContent.includes(keyword)) {
                            elements.push(el);
                        }
                    }
                    if (elements.length > 0) {
                        const preview = [];
                        for (let k = 0; k < elements.length && k < 3; k++) {
                            preview.push(elements[k]);
                        }
                        keywordElements.push({ keyword, count: elements.length, elements: preview });
                    }
                }
                
                debugLog("å…³é”®è¯æœç´¢ç»“æœ:", keywordElements);
                
                // æ£€æŸ¥é¡µé¢ä¸­çš„æ‰€æœ‰æ–‡æœ¬å†…å®¹
                const bodyText = document.body.textContent;
                const hasKeywords = [
                    bodyText.includes('æœªè¯„'),
                    bodyText.includes('å·²è¯„'),
                    bodyText.includes('è¯¾ç¨‹'),
                    bodyText.includes('æ•™å¸ˆ'),
                    bodyText.includes('è¯„ä»·')
                ];
                
                debugLog("é¡µé¢å…³é”®è¯æ£€æŸ¥:", hasKeywords);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰iframe
                const iframes = document.querySelectorAll('iframe');
                if (iframes.length > 0) {
                    debugLog("å‘ç°iframe:", iframes);
                }
            }
            
        } catch (error) {
            updateStatus("æµ‹è¯•å¤±è´¥: " + error.message);
            debugLog("æµ‹è¯•å¤±è´¥", error);
        }
    }
    
    // æ˜¾ç¤ºç»“æœ
    function showResults() {
        if (evaluationResults.length === 0) return;
        
        let successCount = 0;
        for (let i = 0; i < evaluationResults.length; i++) {
            if (evaluationResults[i] && evaluationResults[i].success) {
                successCount++;
            }
        }
        const failCount = evaluationResults.length - successCount;
        
        const resultsHtml = `
            <div style="margin-top: 10px; padding: 10px; background: #e9ecef; border-radius: 4px; font-size: 12px;">
                <strong>è¯„ä»·ç»“æœç»Ÿè®¡:</strong><br>
                æˆåŠŸ: ${successCount} | å¤±è´¥: ${failCount} | æ€»è®¡: ${evaluationResults.length}
            </div>
        `;
        
        const statusElement = document.getElementById('status');
        if (statusElement) {
            statusElement.innerHTML += resultsHtml;
        }
        
        // è¯¦ç»†ç»“æœ
        let detailedResults = '';
        for (let i = 0; i < evaluationResults.length; i++) {
            const result = evaluationResults[i];
            const status = result && result.success ? 'âœ…' : 'âŒ';
            const error = result && result.error ? ` (${result.error})` : '';
            const name = result && result.course ? result.course.courseName : 'æœªçŸ¥è¯¾ç¨‹';
            const line = `${i + 1}. ${status} ${name}${error}`;
            detailedResults += (i === 0 ? line : '<br>' + line);
        }
        
        debugLog("è¯¦ç»†è¯„ä»·ç»“æœ", detailedResults);
    }
    
    // ==================== åˆå§‹åŒ– ====================
    
    // ç­‰å¾…é¡µé¢å®Œå…¨åŠ è½½ - å·²ä¼˜åŒ–ï¼šç§»é™¤å¼ºåˆ¶ç­‰å¾…ï¼Œæ¡ä»¶æ»¡è¶³å³é€šè¿‡
    async function waitForPageLoad() {
        debugLog("ç­‰å¾…é¡µé¢å®Œå…¨åŠ è½½...");
        const maxWaitTime = 15000; // æœ€å¤§ç­‰å¾…15ç§’ï¼ˆä»60ç§’ä¼˜åŒ–ï¼‰
        const checkInterval = 300;  // æ¯300msæ£€æŸ¥ä¸€æ¬¡ï¼ˆä»1ç§’ä¼˜åŒ–ï¼‰
        let waitTime = 0;
        
        while (waitTime < maxWaitTime) {
            // æ£€æŸ¥é¡µé¢åŠ è½½çŠ¶æ€
            const isPageReady = document.readyState === 'complete' &&
                               document.body &&
                               document.body.children.length > 0;
            
            // æ£€æŸ¥å…³é”®å…ƒç´ æ˜¯å¦å­˜åœ¨
            const hasJqGrid = document.querySelector('#tempGrid') !== null;
            const hasTables = document.querySelectorAll('table').length > 0;
            const hasContent = document.body.textContent.length > 500; // é™ä½å†…å®¹è¦æ±‚
            
            // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰åŠ è½½æŒ‡ç¤ºå™¨
            const loadingIndicators = document.querySelectorAll('.loading, .spinner, [class*="loading"]');
            const hasLoading = safeSome(loadingIndicators, (indicator) => {
                if (!indicator || !indicator.style) return false;
                return indicator.offsetParent !== null && indicator.style.display !== 'none';
            });
            
            // åªåœ¨é¦–æ¬¡å’Œæ¯ç§’è¾“å‡ºä¸€æ¬¡æ—¥å¿—ï¼Œé¿å…åˆ·å±
            if (waitTime === 0 || waitTime % 1000 === 0) {
                debugLog(`é¡µé¢çŠ¶æ€æ£€æŸ¥: å°±ç»ª=${isPageReady}, jqGrid=${hasJqGrid}, è¡¨æ ¼=${hasTables}, å†…å®¹=${hasContent}, åŠ è½½ä¸­=${hasLoading}`);
            }
            
            // ä¼˜åŒ–åçš„å°±ç»ªæ¡ä»¶ï¼ˆç§»é™¤å¼ºåˆ¶3ç§’ç­‰å¾…ï¼‰ï¼š
            // æ¡ä»¶1ï¼šæœ‰jqGridè¡¨æ ¼ï¼ˆæœ€å¯é çš„æ ‡è¯†ï¼‰
            if (hasJqGrid && isPageReady) {
                debugLog("é¡µé¢åŠ è½½å®Œæˆï¼ˆæ£€æµ‹åˆ°jqGridï¼‰");
                return true;
            }
            
            // æ¡ä»¶2ï¼šé¡µé¢å°±ç»ª + æœ‰å†…å®¹ + æ— åŠ è½½æŒ‡ç¤ºå™¨
            if (isPageReady && hasContent && !hasLoading && hasTables) {
                debugLog("é¡µé¢åŠ è½½å®Œæˆï¼ˆæ¡ä»¶æ»¡è¶³ï¼‰");
                return true;
            }
            
            // æ¡ä»¶3ï¼šç­‰å¾…è¶…è¿‡1.5ç§’ä¸”åŸºæœ¬æ¡ä»¶æ»¡è¶³
            if (waitTime > 1500 && isPageReady && hasContent) {
                debugLog("é¡µé¢åŠ è½½å®Œæˆï¼ˆè¶…æ—¶ä½†åŸºæœ¬æ¡ä»¶æ»¡è¶³ï¼‰");
                return true;
            }
            
            await sleep(checkInterval);
            waitTime += checkInterval;
        }
        
        debugLog("é¡µé¢åŠ è½½ç­‰å¾…è¶…æ—¶ï¼Œä½†ç»§ç»­æ‰§è¡Œ");
        return true;
    }
    
    // é¢„åŠ è½½ï¼šè®¾ç½®æ¯é¡µæ˜¾ç¤ºæ¡æ•°ä¸º50 - å·²ä¼˜åŒ–
    async function preloadPageSize() {
        try {
            const target = '50';
            
            // ç­‰å¾…ä¸‹æ‹‰æ¡†å‡ºç°ï¼ˆæœ€å¤šç­‰å¾…1ç§’ï¼‰- å·²ä¼˜åŒ–
            let select = null;
            for (let i = 0; i < 10; i++) {
                select = document.querySelector('select.ui-pg-selbox[name="currentPage"]');
                if (select) break;
                await sleep(100);
            }
            
            if (!select) {
                debugLog('é¢„åŠ è½½ï¼šæœªæ‰¾åˆ°æ¯é¡µæ¡æ•°ä¸‹æ‹‰æ¡†');
                return false;
            }

            const current = String(select.value || '');
            if (current === target) {
                debugLog('é¢„åŠ è½½ï¼šæ¯é¡µæ¡æ•°å·²ç»æ˜¯50ï¼Œæ— éœ€ä¿®æ”¹');
                return true;
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰ç›®æ ‡é€‰é¡¹
            let hasOption = false;
            const options = select.options || [];
            for (let i = 0; i < options.length; i++) {
                if (String(options[i]?.value) === target) {
                    hasOption = true;
                    break;
                }
            }
            if (!hasOption) {
                debugLog('é¢„åŠ è½½ï¼šä¸‹æ‹‰æ¡†ä¸­æ²¡æœ‰50è¿™ä¸ªé€‰é¡¹');
                return false;
            }

            // è®¾ç½®æ–°å€¼å¹¶è§¦å‘äº‹ä»¶
            select.value = target;
            select.dispatchEvent(new Event('change', { bubbles: true }));
            if (typeof jQuery !== 'undefined') {
                try { jQuery(select).trigger('change'); } catch (e) {}
            }

            debugLog(`é¢„åŠ è½½ï¼šæ¯é¡µæ¡æ•° ${current} â†’ ${target}`);
            
            // ç­‰å¾…æ•°æ®é‡æ–°åŠ è½½å®Œæˆ
            await waitForDataReload();
            
            return true;
        } catch (e) {
            debugLog('é¢„åŠ è½½æ¯é¡µæ¡æ•°å¤±è´¥', e);
            return false;
        }
    }
    
    // ç­‰å¾…æ•°æ®é‡æ–°åŠ è½½å®Œæˆ - å·²ä¼˜åŒ–
    async function waitForDataReload() {
        debugLog('ç­‰å¾…æ•°æ®é‡æ–°åŠ è½½...');
        const maxWait = 2000;   // ä»5ç§’ä¼˜åŒ–åˆ°2ç§’
        const checkInterval = 100;  // ä»200msä¼˜åŒ–åˆ°100ms
        let waited = 0;
        
        // å…ˆç­‰å¾…ä¸€å°æ®µæ—¶é—´è®©è¯·æ±‚å‘å‡º
        await sleep(150);
        
        while (waited < maxWait) {
            // æ£€æŸ¥æ•°æ®è¡Œæ•°é‡ï¼ˆç®€åŒ–æ£€æµ‹é€»è¾‘ï¼‰
            const rows = document.querySelectorAll('#tempGrid tr.ui-widget-content.jqgrow');
            if (rows.length > 15) {
                debugLog(`æ•°æ®åŠ è½½å®Œæˆï¼Œå½“å‰è¡Œæ•°: ${rows.length}`);
                return true;
            }
            
            await sleep(checkInterval);
            waited += checkInterval;
        }
        
        debugLog('æ•°æ®åŠ è½½ç­‰å¾…è¶…æ—¶ï¼Œç»§ç»­æ‰§è¡Œ');
        return true;  // è¶…æ—¶ä¹Ÿç»§ç»­
    }

    // é¡µé¢åŠ è½½å®Œæˆååˆ›å»ºæ§åˆ¶é¢æ¿
    async function initialize() {
        try {
            // ç­‰å¾…é¡µé¢å®Œå…¨åŠ è½½
            await waitForPageLoad();
            
            startInjectionWarningAutoCloser();
            
            // åˆ›å»ºæ§åˆ¶é¢æ¿
            createControlPanel();
            
            // é¢„åŠ è½½ï¼šè®¾ç½®æ¯é¡µæ˜¾ç¤º50æ¡ï¼ˆæå‰åŠ è½½æ•°æ®ï¼‰+ è‡ªåŠ¨æµ‹è¯•
            debugLog('å¼€å§‹é¢„åŠ è½½æ¯é¡µæ¡æ•°...');
            preloadPageSize().then(() => {
                debugLog("é¢„åŠ è½½å®Œæˆï¼Œæ‰§è¡Œè‡ªåŠ¨æµ‹è¯•...");
                // é¢„åŠ è½½å®Œæˆåè‡ªåŠ¨æ‰§è¡Œæµ‹è¯•åŠŸèƒ½
                const testBtn = document.getElementById('test-btn');
                if (testBtn) {
                    testBtn.click();
                }
            });
            
            debugLog("è„šæœ¬åˆå§‹åŒ–å®Œæˆ");
            
        } catch (error) {
            debugLog("åˆå§‹åŒ–è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯", error);
            // å³ä½¿å‡ºé”™ä¹Ÿè¦åˆ›å»ºæ§åˆ¶é¢æ¿
            startInjectionWarningAutoCloser();
            createControlPanel();
        }
    }
    
    // å¯åŠ¨è„šæœ¬
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        initialize();
    }
    
})();